<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Flask用户管理</title>
    <link href="/2020/03/15/Flask%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <url>/2020/03/15/Flask%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://mali-mali.github.io/2020/03/07/%E4%BD%BF%E7%94%A8Flask%E5%88%9B%E5%BB%BApython%20http%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">上一篇</a> 中，我们使用了Flask创建了一个python的http后台服务，<br>今天我们来讲讲如何在其中实现用户的登录管理。</p><h2 id="api初始化"><a href="#api初始化" class="headerlink" title="api初始化"></a>api初始化</h2><p>首先同样的初始化我们的api</p><pre><code>from flask import Flaskfrom flask_login import LoginManagerfrom flask_migrate import Migratefrom flask_sqlalchemy import SQLAlchemydb = SQLAlchemy()login_manager = LoginManager()login_manager.session_protection = &#39;strong&#39;def start_aip(config_name, collection=None):    &quot;&quot;&quot;    初始化API    :param config_name:    :param collection:    :return:    &quot;&quot;&quot;    app = Flask(__name__)    db.init_app(app)    Migrate(app, db)    login_manager.init_app(app)    from test.my_info import api    api.init_app(app, version=&#39;1.0&#39;, title=&#39;API&#39;, description=&#39;A test API&#39;)    return app</code></pre><h2 id="登录验证"><a href="#登录验证" class="headerlink" title="登录验证"></a>登录验证</h2><p>这里创建一个User.py</p><pre><code>import timeimport functoolsfrom datetime import datetimefrom flask import jsonify, requestfrom flask_login import UserMixinfrom itsdangerous import TimedJSONWebSignatureSerializer as Serializerfrom werkzeug.security import generate_password_hash, check_password_hashfrom config import settingsfrom ..models.error import unauthorized, forbiddenfrom .. import dbfrom .. import login_managerclass User(UserMixin, db.Model):    &quot;&quot;&quot;    用户表    :param: UserMixin    :param: db.Model    :return:    &quot;&quot;&quot;    __tablename__ = &#39;users&#39;    id = db.Column(db.Integer, primary_key=True)    email = db.Column(db.String(64), unique=True, index=True)    username = db.Column(db.String(64), unique=True, index=True)    password_hash = db.Column(db.String(128))    confirmed = db.Column(db.Boolean, default=False)    name = db.Column(db.String(64))    location = db.Column(db.String(64))    about_me = db.Column(db.Text())    member_since = db.Column(db.DateTime(), default=datetime.utcnow)    last_seen = db.Column(db.DateTime(), default=datetime.utcnow)    avatar_hash = db.Column(db.String(32))    tokenTime = time.mktime(datetime.now().timetuple())    def generate_auth_token(self, expiration):        &quot;&quot;&quot;        生成token        :return:        &quot;&quot;&quot;        s = Serializer(settings.Config.SECRET_KEY, expires_in=expiration)        token = s.dumps({&#39;id&#39;: self.id}).decode(&#39;ascii&#39;)        return token    def verify_password(self, password):        return check_password_hash(self.password_hash, password)@login_manager.user_loaderdef load_user(user_id):    return User.query.get(int(user_id))def login_required(view_func):    @functools.wraps(view_func)    def verify_token(*args, **kwargs):        try:            # 在请求头上拿到token            token = request.headers[&quot;token&quot;]        except Exception:            # 没接收的到token,给前端抛出错误            return forbidden(&#39;缺少参数token&#39;)        s = Serializer(settings.Config.SECRET_KEY)        try:            s.loads(token)        except Exception:            # print(&quot;验证失败, 无效的token&quot;)            return unauthorized(&#39;验证失败, 无效的token&#39;)        return view_func(*args, **kwargs)    return verify_token</code></pre><h2 id="接口及其他"><a href="#接口及其他" class="headerlink" title="接口及其他"></a>接口及其他</h2><p>最后我们只需要建立我们的登录接口即可</p><pre><code>upload_parser = reqparse.RequestParser()upload_parser.add_argument(&#39;token&#39;, type=str, location=&#39;headers&#39;)user = api.namespace(&#39;Login&#39;, path=&#39;/&#39;, description=&#39;hello world&#39;)## 应为我们之前使用了swagger在线api这里需要编辑请求时需要传递的参数（可以忽略）login_model = smart_tax.api.model(&#39;Login&#39;, {    &#39;username&#39;: fields.String(description=&#39;用户名, 默认:admin&#39;),    &#39;password&#39;: fields.String(description=&#39;密码, 默认:yiyetong123&#39;)})@user.route(&#39;/login&#39;)class login(Resource):    &quot;&quot;&quot;    登录：    &quot;&quot;&quot;    @user.expect(login_model)    def post(self):        &#39;&#39;&#39;登录&#39;&#39;&#39;        username = api.payload.get(&#39;username&#39;, None)        password = api.payload.get(&#39;password&#39;, None)        user = User.query.filter_by(username=username).first()        if user is not None and user.verify_password(password):            login_user(user)            return jsonify({&#39;code&#39;: 200, &#39;token&#39;: user.generate_auth_token(tokenExpiration), &#39;expiration&#39;: tokenExpiration})        else:            return unauthorized(&#39;Invalid username or password.&#39;)    # def get(self):    #     &#39;&#39;&#39;验证失败自动跳转&#39;&#39;&#39;    #     return unauthorized(&#39;Unauthorized.&#39;)@user.route(&#39;/logout&#39;)class logout(Resource):    &quot;&quot;&quot;    登出    &quot;&quot;&quot;    @login_required    @user.expect(upload_parser)    def get(self):        &#39;&#39;&#39;登出&#39;&#39;&#39;        logout_user()        logoutMessage = {&quot;message&quot;: &#39;You have been logged out.&#39;}        flash(logoutMessage)        return jsonify(logoutMessage)</code></pre><blockquote><p>在需要进行登录校验的接口上添加 @login_required 后该接口必须输入登入时返回的token信息才可访问， @user.expect(upload_parser) 为swagger在线api的装饰器。</p></blockquote><h3 id="自定义错误信息"><a href="#自定义错误信息" class="headerlink" title="自定义错误信息"></a>自定义错误信息</h3><pre><code>def bad_request(message):    &quot;&quot;&quot;    服务器不理解客户端的请求，未做任何处理。    :param message:    :return:    &quot;&quot;&quot;    return {&#39;code&#39;: 400, &#39;message&#39;: message, &#39;data&#39;: None}def unauthorized(message):    &quot;&quot;&quot;    用户未提供身份验证凭据，或者没有通过身份验证。    :param message:    :return:    &quot;&quot;&quot;    return {&#39;code&#39;: 401, &#39;message&#39;: message, &#39;data&#39;: None}    # return plugin.api.abort(code=200, message=message)def forbidden(message):    &quot;&quot;&quot;    用户通过了身份验证，但是不具有访问资源所需的权限。    :param message:    :return:    &quot;&quot;&quot;    return {&#39;code&#39;: 403, &#39;message&#39;: message, &#39;data&#39;: None}def NotFound(message):    &quot;&quot;&quot;    :param message:    :return:    &quot;&quot;&quot;    return {&#39;code&#39;: 404, &#39;message&#39;: message, &#39;data&#39;: None}def NotFoundDevice(message):    &quot;&quot;&quot;    :param message:    :return:    &quot;&quot;&quot;    return {&#39;code&#39;: 412, &#39;message&#39;: message, &#39;data&#39;: None}def internalServerError(message):    &quot;&quot;&quot;    :param message:    :return:    &quot;&quot;&quot;    return {&#39;code&#39;: 500, &#39;message&#39;: message, &#39;data&#39;: None}def deviceTimeoutError(message):    &quot;&quot;&quot;    :param message:    :return:    &quot;&quot;&quot;    return {&#39;code&#39;: 501, &#39;message&#39;: message, &#39;data&#39;: None}def parameterError(message):    &quot;&quot;&quot;    :param message:    :return:    &quot;&quot;&quot;    return {&#39;code&#39;: 502, &#39;message&#39;: message, &#39;data&#39;: None}def successful(data):    &quot;&quot;&quot;    成功    :param data:    :return:    &quot;&quot;&quot;    return {&#39;code&#39;: 200, &#39;message&#39;: None, &#39;data&#39;: data}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>flask</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QWebEngineView与网页JS进行交互 忽略网页SSL证书错误</title>
    <link href="/2020/03/10/QWebEngineView%E4%B8%8E%E7%BD%91%E9%A1%B5JS%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92%20%E5%BF%BD%E7%95%A5%E7%BD%91%E9%A1%B5SSL%E8%AF%81%E4%B9%A6%E9%94%99%E8%AF%AF/"/>
    <url>/2020/03/10/QWebEngineView%E4%B8%8E%E7%BD%91%E9%A1%B5JS%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92%20%E5%BF%BD%E7%95%A5%E7%BD%91%E9%A1%B5SSL%E8%AF%81%E4%B9%A6%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<p>之前我们讲到了使用QtWebEngineWidgets模块开发一个内嵌webview的Qt5客户端界面。竟然我们使用了内嵌式的webview那就免不了要与网页JS代码进行一些交互，今天我们就说说如何使我们的python程序与网页JS进行交互。</p><h2 id="QWebEngineView与网页JS进行交互"><a href="#QWebEngineView与网页JS进行交互" class="headerlink" title="QWebEngineView与网页JS进行交互"></a>QWebEngineView与网页JS进行交互</h2><p>这里我们需要先用到PyQt5.QtWebChannel，并且重写一个我们的webview类，继承至QWebEngineView. <a href="https://blog.csdn.net/kaida1234/article/details/80422704" target="_blank" rel="noopener">参考</a></p><pre><code>from PyQt5.QtWebEngineWidgets import QWebEngineViewfrom PyQt5.QtCore import QObject, pyqtSignal, pyqtSlotfrom PyQt5.QtWebChannel import QWebChannelclass My_Browser(QWebEngineView):    SigSendMessageToJS = pyqtSignal(str)    def __init__(self, parent):        super().__init__(parent)        self.pWebChannel = QWebChannel(self.page())        self.pInteractObj = TInteractObj(self)        self.pWebChannel.registerObject(&quot;interactObj&quot;, self.pInteractObj)        self.page().setWebChannel(self.pWebChannel)        self.pInteractObj.SigReceivedMessFromJS.connect(self.OnReceiveMessageFromJS)        self.SigSendMessageToJS.connect(self.pInteractObj.SigSendMessageToJS)    def OnReceiveMessageFromJS(self, strParameter):        print(&#39;OnReceiveMessageFromJS()&#39;)        if not strParameter:            return        print(&#39;FromJS Messiage:&#39; + strParameter)    def OnSendMessageByInteractObj(self, strMessage):        if not strMessage:            return        self.SigSendMessageToJS.emit(strMessage)class TInteractObj(QObject):    SigReceivedMessFromJS = pyqtSignal(str)    SigSendMessageToJS = pyqtSignal(str)    def __init__(self, parent=None):        super().__init__(parent)    @pyqtSlot(str)    def JSSendMessage(self, strParameter):        print(&#39;JSSendMessage(%s) from Html&#39; % strParameter)        self.SigReceivedMessFromJS.emit(strParameter)    @pyqtSlot(result=str)    def fun(self):        print(&#39;TInteractObj.fun()&#39;)        return &#39;hello&#39;</code></pre><blockquote><p>这里TInteractObj类需要继承至QObject</p></blockquote><h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><pre><code>&lt;!DOCTYPE html&gt;  &lt;html&gt;      &lt;head&gt;          &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;          &lt;script type=&quot;text/javascript&quot; src=&quot;./qwebchannel.js&quot;&gt;&lt;/script&gt;          &lt;script type=&quot;text/javascript&quot;&gt;          //---Web show receive message---        function output(message)          {              var output = document.getElementById(&quot;output&quot;);              output.innerHTML = output.innerHTML + message + &quot;\n&quot;;          }          function showAlert()         {            alert(&#39;this is web alert&#39;);        }        //Web initial loading          window.onload = function()          {            new QWebChannel(qt.webChannelTransport, function(channel)             {                //Get Qt interact object                  var interactObj = channel.objects.interactObj;                 //Web send message to Qt                 document.getElementById(&quot;send&quot;).onclick = function()                 {                    var input = document.getElementById(&quot;input&quot;);                    if (!input.value)                     {                          return;                      }                      output(&quot;Send string to Qt: &quot; + input.value);                      //Web use the interface of Qt                     // interactObj.fun(alert);                    interactObj.JSSendMessage(input.value);                      input.value = &quot;&quot;;                                      }                  //Web connect the Qt signal, then Qt can call &quot;output&quot; function                interactObj.SigSendMessageToJS.connect(function(str)                {                      output(&quot;Received string from Qt: &quot; + str);                  });            });          }          &lt;/script&gt;          &lt;style type=&quot;text/css&quot;&gt;              html {                  height: 100%;                  width: 100%;              }              #input {                  width: 650px;                  margin: 0 10px 0 0;              }              #send {                  width: 90px;                  margin: 0;              }              #output {                  width: 770px;                  height: 550px;              }          &lt;/style&gt;      &lt;/head&gt;      &lt;body&gt;          &lt;textarea id=&quot;output&quot; readonly=&quot;readonly&quot;&gt;&lt;/textarea&gt;&lt;br /&gt;          &lt;input id=&quot;input&quot; /&gt;          &lt;input type=&quot;submit&quot; id=&quot;send&quot; value=&quot;Send&quot; οnclick=&quot;javascript:click();&quot; /&gt;      &lt;/body&gt;  &lt;/html&gt;</code></pre><blockquote><p>这里有一些需要注意的地方是js中定义的槽函数名需要和python中定义的一致，否则是无效的。</p></blockquote><h3 id="qwebchannel-js"><a href="#qwebchannel-js" class="headerlink" title="qwebchannel.js"></a>qwebchannel.js</h3><p>另外我们还需要一个qwebchannel.js脚本，使用时需要在html中引用</p><pre><code>/******************************************************************************** Copyright (C) 2016 The Qt Company Ltd.** Contact: http://www.qt.io/licensing/**** This file is part of the examples of the Qt Toolkit.**** $QT_BEGIN_LICENSE:BSD$** You may use this file under the terms of the BSD license as follows:**** &quot;Redistribution and use in source and binary forms, with or without** modification, are permitted provided that the following conditions are** met:**   * Redistributions of source code must retain the above copyright**     notice, this list of conditions and the following disclaimer.**   * Redistributions in binary form must reproduce the above copyright**     notice, this list of conditions and the following disclaimer in**     the documentation and/or other materials provided with the**     distribution.**   * Neither the name of The Qt Company Ltd nor the names of its**     contributors may be used to endorse or promote products derived**     from this software without specific prior written permission.****** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;**** $QT_END_LICENSE$******************************************************************************/&quot;use strict&quot;;var QWebChannelMessageTypes = {    signal: 1,    propertyUpdate: 2,    init: 3,    idle: 4,    debug: 5,    invokeMethod: 6,    connectToSignal: 7,    disconnectFromSignal: 8,    setProperty: 9,    response: 10,};var QWebChannel = function(transport, initCallback){    if (typeof transport !== &quot;object&quot; || typeof transport.send !== &quot;function&quot;) {        console.error(&quot;The QWebChannel expects a transport object with a send function and onmessage callback property.&quot; +                      &quot; Given is: transport: &quot; + typeof(transport) + &quot;, transport.send: &quot; + typeof(transport.send));        return;    }    var channel = this;    this.transport = transport;    this.send = function(data)    {        if (typeof(data) !== &quot;string&quot;) {            data = JSON.stringify(data);        }        channel.transport.send(data);    }    this.transport.onmessage = function(message)    {        var data = message.data;        if (typeof data === &quot;string&quot;) {            data = JSON.parse(data);        }        switch (data.type) {            case QWebChannelMessageTypes.signal:                channel.handleSignal(data);                break;            case QWebChannelMessageTypes.response:                channel.handleResponse(data);                break;            case QWebChannelMessageTypes.propertyUpdate:                channel.handlePropertyUpdate(data);                break;            default:                console.error(&quot;invalid message received:&quot;, message.data);                break;        }    }    this.execCallbacks = {};    this.execId = 0;    this.exec = function(data, callback)    {        if (!callback) {            // if no callback is given, send directly            channel.send(data);            return;        }        if (channel.execId === Number.MAX_VALUE) {            // wrap            channel.execId = Number.MIN_VALUE;        }        if (data.hasOwnProperty(&quot;id&quot;)) {            console.error(&quot;Cannot exec message with property id: &quot; + JSON.stringify(data));            return;        }        data.id = channel.execId++;        channel.execCallbacks[data.id] = callback;        channel.send(data);    };    this.objects = {};    this.handleSignal = function(message)    {        var object = channel.objects[message.object];        if (object) {            object.signalEmitted(message.signal, message.args);        } else {            console.warn(&quot;Unhandled signal: &quot; + message.object + &quot;::&quot; + message.signal);        }    }    this.handleResponse = function(message)    {        if (!message.hasOwnProperty(&quot;id&quot;)) {            console.error(&quot;Invalid response message received: &quot;, JSON.stringify(message));            return;        }        channel.execCallbacks[message.id](message.data);        delete channel.execCallbacks[message.id];    }    this.handlePropertyUpdate = function(message)    {        for (var i in message.data) {            var data = message.data[i];            var object = channel.objects[data.object];            if (object) {                object.propertyUpdate(data.signals, data.properties);            } else {                console.warn(&quot;Unhandled property update: &quot; + data.object + &quot;::&quot; + data.signal);            }        }        channel.exec({type: QWebChannelMessageTypes.idle});    }    this.debug = function(message)    {        channel.send({type: QWebChannelMessageTypes.debug, data: message});    };    channel.exec({type: QWebChannelMessageTypes.init}, function(data) {        for (var objectName in data) {            var object = new QObject(objectName, data[objectName], channel);        }        // now unwrap properties, which might reference other registered objects        for (var objectName in channel.objects) {            channel.objects[objectName].unwrapProperties();        }        if (initCallback) {            initCallback(channel);        }        channel.exec({type: QWebChannelMessageTypes.idle});    });};function QObject(name, data, webChannel){    this.__id__ = name;    webChannel.objects[name] = this;    // List of callbacks that get invoked upon signal emission    this.__objectSignals__ = {};    // Cache of all properties, updated when a notify signal is emitted    this.__propertyCache__ = {};    var object = this;    // ----------------------------------------------------------------------    this.unwrapQObject = function(response)    {        if (response instanceof Array) {            // support list of objects            var ret = new Array(response.length);            for (var i = 0; i &lt; response.length; ++i) {                ret[i] = object.unwrapQObject(response[i]);            }            return ret;        }        if (!response            || !response[&quot;__QObject*__&quot;]            || response.id === undefined) {            return response;        }        var objectId = response.id;        if (webChannel.objects[objectId])            return webChannel.objects[objectId];        if (!response.data) {            console.error(&quot;Cannot unwrap unknown QObject &quot; + objectId + &quot; without data.&quot;);            return;        }        var qObject = new QObject( objectId, response.data, webChannel );        qObject.destroyed.connect(function() {            if (webChannel.objects[objectId] === qObject) {                delete webChannel.objects[objectId];                // reset the now deleted QObject to an empty {} object                // just assigning {} though would not have the desired effect, but the                // below also ensures all external references will see the empty map                // NOTE: this detour is necessary to workaround QTBUG-40021                var propertyNames = [];                for (var propertyName in qObject) {                    propertyNames.push(propertyName);                }                for (var idx in propertyNames) {                    delete qObject[propertyNames[idx]];                }            }        });        // here we are already initialized, and thus must directly unwrap the properties        qObject.unwrapProperties();        return qObject;    }    this.unwrapProperties = function()    {        for (var propertyIdx in object.__propertyCache__) {            object.__propertyCache__[propertyIdx] = object.unwrapQObject(object.__propertyCache__[propertyIdx]);        }    }    function addSignal(signalData, isPropertyNotifySignal)    {        var signalName = signalData[0];        var signalIndex = signalData[1];        object[signalName] = {            connect: function(callback) {                if (typeof(callback) !== &quot;function&quot;) {                    console.error(&quot;Bad callback given to connect to signal &quot; + signalName);                    return;                }                object.__objectSignals__[signalIndex] = object.__objectSignals__[signalIndex] || [];                object.__objectSignals__[signalIndex].push(callback);                if (!isPropertyNotifySignal &amp;&amp; signalName !== &quot;destroyed&quot;) {                    // only required for &quot;pure&quot; signals, handled separately for properties in propertyUpdate                    // also note that we always get notified about the destroyed signal                    webChannel.exec({                        type: QWebChannelMessageTypes.connectToSignal,                        object: object.__id__,                        signal: signalIndex                    });                }            },            disconnect: function(callback) {                if (typeof(callback) !== &quot;function&quot;) {                    console.error(&quot;Bad callback given to disconnect from signal &quot; + signalName);                    return;                }                object.__objectSignals__[signalIndex] = object.__objectSignals__[signalIndex] || [];                var idx = object.__objectSignals__[signalIndex].indexOf(callback);                if (idx === -1) {                    console.error(&quot;Cannot find connection of signal &quot; + signalName + &quot; to &quot; + callback.name);                    return;                }                object.__objectSignals__[signalIndex].splice(idx, 1);                if (!isPropertyNotifySignal &amp;&amp; object.__objectSignals__[signalIndex].length === 0) {                    // only required for &quot;pure&quot; signals, handled separately for properties in propertyUpdate                    webChannel.exec({                        type: QWebChannelMessageTypes.disconnectFromSignal,                        object: object.__id__,                        signal: signalIndex                    });                }            }        };    }    /**     * Invokes all callbacks for the given signalname. Also works for property notify callbacks.     */    function invokeSignalCallbacks(signalName, signalArgs)    {        var connections = object.__objectSignals__[signalName];        if (connections) {            connections.forEach(function(callback) {                callback.apply(callback, signalArgs);            });        }    }    this.propertyUpdate = function(signals, propertyMap)    {        // update property cache        for (var propertyIndex in propertyMap) {            var propertyValue = propertyMap[propertyIndex];            object.__propertyCache__[propertyIndex] = propertyValue;        }        for (var signalName in signals) {            // Invoke all callbacks, as signalEmitted() does not. This ensures the            // property cache is updated before the callbacks are invoked.            invokeSignalCallbacks(signalName, signals[signalName]);        }    }    this.signalEmitted = function(signalName, signalArgs)    {        invokeSignalCallbacks(signalName, signalArgs);    }    function addMethod(methodData)    {        var methodName = methodData[0];        var methodIdx = methodData[1];        object[methodName] = function() {            var args = [];            var callback;            for (var i = 0; i &lt; arguments.length; ++i) {                if (typeof arguments[i] === &quot;function&quot;)                    callback = arguments[i];                else                    args.push(arguments[i]);            }            webChannel.exec({                &quot;type&quot;: QWebChannelMessageTypes.invokeMethod,                &quot;object&quot;: object.__id__,                &quot;method&quot;: methodIdx,                &quot;args&quot;: args            }, function(response) {                if (response !== undefined) {                    var result = object.unwrapQObject(response);                    if (callback) {                        (callback)(result);                    }                }            });        };    }    function bindGetterSetter(propertyInfo)    {        var propertyIndex = propertyInfo[0];        var propertyName = propertyInfo[1];        var notifySignalData = propertyInfo[2];        // initialize property cache with current value        // NOTE: if this is an object, it is not directly unwrapped as it might        // reference other QObject that we do not know yet        object.__propertyCache__[propertyIndex] = propertyInfo[3];        if (notifySignalData) {            if (notifySignalData[0] === 1) {                // signal name is optimized away, reconstruct the actual name                notifySignalData[0] = propertyName + &quot;Changed&quot;;            }            addSignal(notifySignalData, true);        }        Object.defineProperty(object, propertyName, {            configurable: true,            get: function () {                var propertyValue = object.__propertyCache__[propertyIndex];                if (propertyValue === undefined) {                    // This shouldn&#39;t happen                    console.warn(&quot;Undefined value in property cache for property \&quot;&quot; + propertyName + &quot;\&quot; in object &quot; + object.__id__);                }                return propertyValue;            },            set: function(value) {                if (value === undefined) {                    console.warn(&quot;Property setter for &quot; + propertyName + &quot; called with undefined value!&quot;);                    return;                }                object.__propertyCache__[propertyIndex] = value;                webChannel.exec({                    &quot;type&quot;: QWebChannelMessageTypes.setProperty,                    &quot;object&quot;: object.__id__,                    &quot;property&quot;: propertyIndex,                    &quot;value&quot;: value                });            }        });    }    // ----------------------------------------------------------------------    data.methods.forEach(addMethod);    data.properties.forEach(bindGetterSetter);    data.signals.forEach(function(signal) { addSignal(signal, false); });    for (var name in data.enums) {        object[name] = data.enums[name];    }}//required for use with nodejsif (typeof module === &#39;object&#39;) {    module.exports = {        QWebChannel: QWebChannel    };}</code></pre><h2 id="忽略网页SSL证书错误"><a href="#忽略网页SSL证书错误" class="headerlink" title="忽略网页SSL证书错误"></a>忽略网页SSL证书错误</h2><p>另外在使用中，当我们打开一些特定网页是会存在SSL错误，而导致QWebEngineView无法打开网页。<br>跳过的方法很简单，只需要重写一下QWebEnginePage.certificateError() 这个函数即可。<a href="https://blog.csdn.net/zencher/article/details/79558919" target="_blank" rel="noopener">参考</a></p><pre><code>from PyQt5.QtWebEngineWidgets import QWebEnginePage...class CustomWebEnginePage(QWebEnginePage):    def certificateError(self, error):        return True</code></pre><p>然后我们在上面My_Browser.<strong>init</strong>()中添加</p><pre><code>        self.setPage(CustomWebEnginePage(self))</code></pre><p>这样即可顺利的忽略SSL错误了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>QWebEngineView</tag>
      
      <tag>SSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Flask创建python http框架</title>
    <link href="/2020/03/07/%E4%BD%BF%E7%94%A8Flask%E5%88%9B%E5%BB%BApython%20http%E6%A1%86%E6%9E%B6/"/>
    <url>/2020/03/07/%E4%BD%BF%E7%94%A8Flask%E5%88%9B%E5%BB%BApython%20http%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>在python中，我们可以很方便的通过flask这个框架来创建一个http的后台服务。还可以通过flask_restplus快速创建一个swagger在线api文档。</p><h2 id="http服务创建"><a href="#http服务创建" class="headerlink" title="http服务创建"></a>http服务创建</h2><p>先来一个简单的 hello world</p><pre><code>#!/usr/bin/env python# -*- coding: utf-8 -*-from flask import Flaskapp = Flask(__name__)@app.route(&#39;/hello&#39;)def helloworld():    return &#39;hello world&#39;if __name__ == &quot;__main__&quot;:    app.run(host=&#39;127.0.0.1&#39;, port=7777, debug=False, threaded=True)</code></pre><h2 id="生成swagger在线api文档"><a href="#生成swagger在线api文档" class="headerlink" title="生成swagger在线api文档"></a>生成swagger在线api文档</h2><p>通常我们都会使用Postman来进行接口的测试，但是多人项目中Postman就有些不方便了。<br>为了方便接口的测试，我们来创建一个swagger在线api文档</p><h3 id="init-py"><a href="#init-py" class="headerlink" title="init.py"></a><strong>init</strong>.py</h3><pre><code>#!/usr/bin/env python# -*- coding: utf-8 -*-from flask_restplus import Api, reqparseapi = Api()hello = api.namespace(&#39;Hello&#39;, path=&#39;/&#39;, description=&#39;hello world&#39;)from . import info</code></pre><blockquote><p>新建一个存放接口代码的文件夹my_info，在<strong>init</strong>.py中输入上面的代码，再在这个目录下创建一个info.py用于存放接口代码。</p></blockquote><h3 id="info-py"><a href="#info-py" class="headerlink" title="info.py"></a>info.py</h3><pre><code>#!/usr/bin/env python# -*- coding: utf-8 -*-from ..my_info import api, hellofrom flask_restplus import Resourcefrom flask_restplus import fieldshello_model = api.model(&#39;hello&#39;, {    &#39;text&#39;: fields.String(description=&#39;测试文字&#39;)})@hello.route(&#39;/hello&#39;)class helloworld(Resource):    def get(self):        return &#39;hello world&#39;    @hello.expect(hello_model)    def post(self):        return api.payload.get(&#39;text&#39;, &#39;没有发送内容!&#39;)</code></pre><p>再对初始化服务代码进行一些修改</p><pre><code>#!/usr/bin/env python# -*- coding: utf-8 -*-from flask import Flaskdef start_aip():    &quot;&quot;&quot;    初始化API    :return:    &quot;&quot;&quot;    app = Flask(__name__)    from test.my_info import api    api.init_app(app, version=&#39;1.0&#39;, title=&#39;API&#39;, description=&#39;A test API&#39;)    return appif __name__ == &quot;__main__&quot;:    app = start_aip()    app.run(host=&#39;127.0.0.1&#39;, port=7777, debug=False, threaded=True)</code></pre><p>这样，我们就开启了一个简单的http服务，并且创建了一个 hello world 接口，以及一个在线api文档。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>flask</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用QtWebEngineWidgets开发Web浏览器</title>
    <link href="/2020/03/02/%E4%BD%BF%E7%94%A8QtWebEngineWidgets%E5%BC%80%E5%8F%91Web%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <url>/2020/03/02/%E4%BD%BF%E7%94%A8QtWebEngineWidgets%E5%BC%80%E5%8F%91Web%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>由于公司的项目常常使用混编模式开发，所以在客户端软件中嵌套web页面就成了必不可少的要求。<br>此次我使用到了PyQt5开发客户端界面，并尝试将web页面嵌套进客户端窗口内。<br>具体使用的Qt模块为QtWebEngineWidgets模块，该模块是在python里是需要单独安装和导入的。</p><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><pre><code>import sysfrom PyQt5.Qt import QApplicationfrom PyQt5.QtCore import QUrlfrom PyQt5.QtWidgets import QWidgetfrom PyQt5.QtWebEngineWidgets import QWebEngineViewclass my_Browser(QWidget):    def __init__(self):        super(my_Browser, self).__init__(None)        self.setFixedSize(1024, 768)        self.browser = QWebEngineView(self)  # web窗口        self.browserInit()  # 生成浏览器控件        self.openUrl(&#39;https://www.baidu.com/&#39;)        # self.openUrl(&#39;/百度一下，你就知道.mhtml&#39;)    def browserInit(self):        &quot;&quot;&quot;创建一个浏览器&quot;&quot;&quot;        self.browser.setFixedSize(1024, 768)    def openUrl(self, url):        &quot;&quot;&quot;打开网页&quot;&quot;&quot;        self.browser.load(QUrl(url))        # self.browser.load(QUrl.fromLocalFile(url))  # 打开本地路径的网页if __name__ == &quot;__main__&quot;:    win = QApplication(sys.argv)    myWin = my_Browser()    myWin.show()    sys.exit(win.exec_())</code></pre><blockquote><p>注意使用网页链接时需要完整的网页地址https和http是必须的；打开本地web文件只需要带人正确的路径即可，我这里直接放在了同一个目录下，百度的页面为.mhtml，当然.html肯定是可以的。</p></blockquote><p>上面为一个简单的案例，这里我在补充一个简单的知识的，开我们的开发中通常不会只是打开一个web页面这么简单，我们还会需要登录后台并实现web页面的自动登录，这里就需要用到cookie了。</p><h2 id="为url添加cookie信息"><a href="#为url添加cookie信息" class="headerlink" title="为url添加cookie信息"></a>为url添加cookie信息</h2><pre><code>from PyQt5.QtWebEngineWidgets import QWebEngineView, QWebEngineProfilefrom PyQt5.QtNetwork import QNetworkCookie    ...    def __init__(self):        super(my_Browser, self).__init__(None)        self.setFixedSize(1024, 768)        self.session = &#39;FSDF45643216546465DSD56464&#39;  # 这里随便瞎写一个，当然我们可以将其作为参数带入    ...    def openUrl(self, url):        &quot;&quot;&quot;打开网页&quot;&quot;&quot;        self.my_cookie = QNetworkCookie()        self.my_cookie.setName(&#39;JSESSIONID&#39;.encode())        self.my_cookie.setValue(self.session.encode())        self.my_cookie.setPath(&#39;/&#39;)        QWebEngineProfile.defaultProfile().cookieStore().deleteAllCookies()        QWebEngineProfile.defaultProfile().cookieStore().setCookie(self.my_cookie, QUrl(url))        self.browser.load(QUrl(url))        # self.browser.load(QUrl.fromLocalFile(url))  # 打开本地路径的网页    ...</code></pre><blockquote><p>QNetworkCookie.setPath(‘/‘)这里为cookie添加路径信息，应为web开发人员可能会将接口文件和页面文件分开放置。</p></blockquote><p>关于使用QtWebEngineWidgets嵌套web页面还有很多知识，我会在之后的使用中在一一记录。</p>]]></content>
    
    
    
    <tags>
      
      <tag>PyQt5</tag>
      
      <tag>QtWebEngineWidgets</tag>
      
      <tag>Web浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyQt5自定义控件之环形进度条</title>
    <link href="/2020/02/28/PyQt5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E4%B9%8B%E7%8E%AF%E5%BD%A2%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    <url>/2020/02/28/PyQt5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E4%B9%8B%E7%8E%AF%E5%BD%A2%E8%BF%9B%E5%BA%A6%E6%9D%A1/</url>
    
    <content type="html"><![CDATA[<p>本文包含了QTimeLine、QPainter模块的运用<br>使用Qpainter绘制圆环图案，QTimeLine实现填充动画。<a href="https://blog.csdn.net/gongjianbo1992/article/details/103571569" target="_blank" rel="noopener">参考</a><br>追加了数字文字的变化动画。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>from PyQt5.Qt import QColor, QRectF, QConicalGradientfrom PyQt5.QtCore import Qt, QTimeLinefrom PyQt5.QtGui import QPainter, QPainterPath, QFontfrom PyQt5.QtWidgets import QLabelclass RingStatistics(QLabel):    def __init__(self, parent, width, color, ring_color=QColor(0, 0, 0, 0), gradient=None):        super(RingStatistics, self).__init__(parent)        # 记录角度        self.angle = 0        self.Ptext = &#39;0&#39;        self.precision = &#39;1&#39;        # 这个是用于绘制的，angle才是真实的角度        self.drawAngle = self.angle        self.drawText = self.Ptext        # 进度条宽度        self.lineWidth = width        # 环形时间轴        self.ringTime = QTimeLine(1000, self)        self.ringTime.frameChanged.connect(self.ringTimeline)        # 文字时间轴        self.textTime = QTimeLine(1000, self)        self.textTime.frameChanged.connect(self.TextTimeline)        # 填充色        self.color = color        self.ring_color = ring_color        # 渐变色        if gradient:            self.gradient = gradient        else:            self.gradient = self.color    def ringTimeline(self, frame):        &quot;&quot;&quot;环形时间轴&quot;&quot;&quot;        self.drawAngle = frame        self.update()    def TextTimeline(self, frame):        &quot;&quot;&quot;文字时间轴&quot;&quot;&quot;        self.drawText = format(float(frame) * float(self.precision), &#39;.&#39; + str(len(self.precision.split(&quot;.&quot;)[1])) + &#39;f&#39;)        self.update()    def setAngle(self, value, text):        &quot;&quot;&quot;设置值、播放动画&quot;&quot;&quot;        self.drawAngle = self.angle        self.angle = int(value * 360)        self.drawText = self.FloatToInt(self.Ptext)        self.Ptext = self.FloatToInt(float(text))        self.ringTime.stop()        self.ringTime.setFrameRange(self.drawAngle, self.angle)        self.ringTime.start()        self.textTime.stop()        self.textTime.setFrameRange(self.drawText, self.Ptext)        self.textTime.start()    def setPText(self, p_str=&#39;0&#39;, size=18, font=&#39;微软雅黑&#39;, color=QColor(0, 0, 0, 0), unit=&#39;&#39;):        &quot;&quot;&quot;初始化绘制的文字&quot;&quot;&quot;        self.Ptext = p_str        self.Psize = size        self.Pfont = font        self.Pcolor = color        self.unit = unit    def paintEvent(self, event):        the_rect = QRectF(0, 0, self.width(), self.height())        if the_rect.isNull():            return        # 画笔        painter = QPainter(self)        painter.fillRect(the_rect, QColor(0, 0, 0, 0))        painter.setRenderHints(QPainter.Antialiasing | QPainter.SmoothPixmapTransform, on=True)        # 镜像翻转，这样就是顺时针        painter.setViewport(self.width(), 0, -self.width(), self.height())        # 填充两个圆相交的部分        the_path = QPainterPath()        the_path.addEllipse(the_rect.adjusted(1, 1, -1, -1))        the_path.addEllipse(the_rect.adjusted(            1 + self.lineWidth, 1 + self.lineWidth, -1 - self.lineWidth, -1 - self.lineWidth))        painter.fillPath(the_path, self.ring_color)        # 径向渐变（参数为中心点和起始角度），默认时从右侧开始逆时针算的        the_gradient = QConicalGradient(the_rect.center(), 90)        the_angle = self.drawAngle / 360        the_gradient.setColorAt(0, self.color)        the_gradient.setColorAt(the_angle, self.gradient)        if the_angle + 0.001 &lt; 1:            the_gradient.setColorAt(the_angle + 0.001, QColor(0, 0, 0, 0))        painter.fillPath(the_path, the_gradient)        p = QPainter(self)        p.setRenderHint(QPainter.TextAntialiasing, True)        p.setPen(self.Pcolor)        p.setFont(QFont(self.Pfont, self.Psize))        if &#39;_&#39; in self.unit:            if self.unit[0] == &#39;_&#39;:                s = str(self.drawText) + self.unit[1:]            else:                s = self.unit[:-1] + str(self.drawText)        else:            s = str(self.drawText)        p.drawText(self.rect(), Qt.AlignCenter, s)    def FloatToInt(self, f):        &quot;&quot;&quot;处理浮点数数据&quot;&quot;&quot;        if &#39;.&#39; in str(f):            self.precision = &#39;0.&#39;            i = 0            while i &lt; len(str(f).split(&quot;.&quot;)[1]):                if i &lt; len(str(f).split(&quot;.&quot;)[1]) - 1:                    self.precision = self.precision + &#39;0&#39;                else:                    self.precision = self.precision + &#39;1&#39;                i += 1            return int(float(f) / float(self.precision))        else:            self.precision = &#39;1&#39;            return int(f)</code></pre><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><pre><code>    def ringTimeline(self, frame):        &quot;&quot;&quot;环形时间轴&quot;&quot;&quot;        self.drawAngle = frame        self.update()    def TextTimeline(self, frame):        &quot;&quot;&quot;文字时间轴&quot;&quot;&quot;        self.drawText = format(float(frame) * float(self.precision), &#39;.&#39; + str(len(self.precision.split(&quot;.&quot;)[1])) + &#39;f&#39;)        self.update()    def setAngle(self, value, text):        &quot;&quot;&quot;设置值、播放动画&quot;&quot;&quot;        self.drawAngle = self.angle        self.angle = int(value * 360)        self.drawText = self.FloatToInt(self.Ptext)        self.Ptext = self.FloatToInt(float(text))        self.ringTime.stop()        self.ringTime.setFrameRange(self.drawAngle, self.angle)        self.ringTime.start()        self.textTime.stop()        self.textTime.setFrameRange(self.drawText, self.Ptext)        self.textTime.start()</code></pre><blockquote><p>QTimeLine.setFrameRange() 设置动画起始值，和目标值。这里参数为 int 类型参数。</p></blockquote><pre><code>    def paintEvent(self, event):        the_rect = QRectF(0, 0, self.width(), self.height())        if the_rect.isNull():            return        # 画笔        painter = QPainter(self)        painter.fillRect(the_rect, QColor(0, 0, 0, 0))        painter.setRenderHints(QPainter.Antialiasing | QPainter.SmoothPixmapTransform, on=True)        # 镜像翻转，这样就是顺时针        painter.setViewport(self.width(), 0, -self.width(), self.height())        # 填充两个圆相交的部分        the_path = QPainterPath()        the_path.addEllipse(the_rect.adjusted(1, 1, -1, -1))        the_path.addEllipse(the_rect.adjusted(            1 + self.lineWidth, 1 + self.lineWidth, -1 - self.lineWidth, -1 - self.lineWidth))        painter.fillPath(the_path, self.ring_color)        # 径向渐变（参数为中心点和起始角度），默认时从右侧开始逆时针算的        the_gradient = QConicalGradient(the_rect.center(), 90)        the_angle = self.drawAngle / 360        the_gradient.setColorAt(0, self.color)        the_gradient.setColorAt(the_angle, self.gradient)        if the_angle + 0.001 &lt; 1:            the_gradient.setColorAt(the_angle + 0.001, QColor(0, 0, 0, 0))        painter.fillPath(the_path, the_gradient)        # 绘制文字        p = QPainter(self)        p.setRenderHint(QPainter.TextAntialiasing, True)        p.setPen(self.Pcolor)        p.setFont(QFont(self.Pfont, self.Psize))        if &#39;_&#39; in self.unit:            if self.unit[0] == &#39;_&#39;:                s = str(self.drawText) + self.unit[1:]            else:                s = self.unit[:-1] + str(self.drawText)        else:            s = str(self.drawText)        p.drawText(self.rect(), Qt.AlignCenter, s)</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="QPainterPath"><a href="#QPainterPath" class="headerlink" title="QPainterPath:"></a>QPainterPath:</h3><pre><code>QPainterPath.addEllipse  # 绘制椭圆形QPainterPath.addPolygon  # 多边形QPainterPath.addRect     # 矩形QPainterPath.addText     # 文字QPainterPath.arcTo       # 弧形QPainterPath.cubicTo     # 贝塞尔曲线</code></pre><h3 id="QRectF"><a href="#QRectF" class="headerlink" title="QRectF"></a>QRectF</h3><pre><code>QRectF.adjusted  # 四个端点的坐标偏移</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>PyQt5</tag>
      
      <tag>样式</tag>
      
      <tag>动画</tag>
      
      <tag>自定义控件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QtWebEngineWidgets在某些设备上崩溃的问题</title>
    <link href="/2020/02/24/QtWebEngineWidgets%E5%9C%A8%E6%9F%90%E4%BA%9B%E8%AE%BE%E5%A4%87%E4%B8%8A%E5%B4%A9%E6%BA%83%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/02/24/QtWebEngineWidgets%E5%9C%A8%E6%9F%90%E4%BA%9B%E8%AE%BE%E5%A4%87%E4%B8%8A%E5%B4%A9%E6%BA%83%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>今天遇到一个比较头疼的问题，使用了QtWebEngineWidgets模块开发的程序导出exe文件之后在某些设备上会崩溃的问题。<br>我碰到的设备具体都是win7的设备。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>这个问题不是很常见，网上答案也不多，大多说的是因为显卡驱动的原因，需要更新显卡驱动。不过我没有试过，具体有没有不知道。</p><p>而我使用的方法呢，是来自 <a href="https://blog.csdn.net/xujun1991/article/details/88122506?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">CSND</a> 上的文章他的第二点：</p><pre><code>2.必须把libEGL.dll、libGLESv2.dll、d3dcompiler_47.dll、opengl32sw.dll这些文件拷贝到对应的exe路径下。</code></pre><p>这里稍微有些不一样的地方，只需要将 程序的运行目录下\PyQt5\Qt\bin 里面的</p><pre><code>libEGL.dll；libGLESv2.dll；d3dcompiler_47.dll；opengl32sw.dll</code></pre><p>四个dll拷贝到exe运行路径下就可以正常运行了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>PyQt5</tag>
      
      <tag>QtWebEngineWidgets</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的PyQt5控件样式表</title>
    <link href="/2020/02/21/%E5%B8%B8%E7%94%A8%E7%9A%84PyQt5%E6%8E%A7%E4%BB%B6%E6%A0%B7%E5%BC%8F%E8%A1%A8/"/>
    <url>/2020/02/21/%E5%B8%B8%E7%94%A8%E7%9A%84PyQt5%E6%8E%A7%E4%BB%B6%E6%A0%B7%E5%BC%8F%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>在最近的工作中大量的使用了PyQt的.setStyleSheet方法来对控件的样式进行自定义，或者制作自己的控件</p><h2 id="常用样式"><a href="#常用样式" class="headerlink" title="常用样式"></a>常用样式</h2><pre><code>背景类：    background:rgb(245,254,254,1);    background-image:url(.../xxx.png);    border-image:url(.../xxx.png);</code></pre><blockquote><p>注意：这里 background-image 和 border-image 都是设置背景图片，区别在于 border-image 图片可以自动适应控件的大小，而 background-image 不行。</p></blockquote><pre><code>文字类：    font-size:14px;  # 字号    font-family:Microsoft YaHei;  # 字体    font-weight:400;  # 笔重    color:rgba(30,159,255,1);  # 颜色    line-height:40px;  # 行距</code></pre><pre><code>边框类：    border:none;  # 无边框    border:1px solid rgb(255, 255, 255, 1);  # 全边框    border-top:1px solid rgb(255, 255, 255, 1);  # 上边框    border-right:1px solid rgb(255, 255, 255, 1);  # 右边框    border-left:1px solid rgb(255, 255, 255, 1);  # 左边框    border-bottom:1px solid rgb(255, 255, 255, 1);  # 下边框    border-radius:60%;  # 圆角，也可以使用像素做参数    padding-top:1px;  # 边距    padding-right:1px;    padding-left:1px;    padding-bottom:1px;    opacity:0.9;  # 透明度</code></pre><h2 id="控件设置"><a href="#控件设置" class="headerlink" title="控件设置"></a>控件设置</h2><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><pre><code>QLabel{font-size:14px;       font-family:Microsoft YaHei;       font-weight:400;       color:rgba(51,51,51,1);       line-height:40px}</code></pre><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><pre><code>QPushButton{background:rgb(255,255,255,1);            border:none;            border-radius:25%}# 鼠标悬停样式            QPushButton:hover{background:rgb(30,159,255,1)}# 选中样式QPushButton:disabled{border-image: url(.../被选中.png)}</code></pre><h3 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h3><pre><code>QComboBox{background:rgba(245,245,245,1);          font-size:14px;          font-family:Microsoft YaHei;          font-weight:400;          color:rgba(51,51,51,1);          line-height:1px;          border:1px solid rgba(179,179,179,1);          border-radius:2px;          padding-left:18px}# 下拉按钮          QComboBox::drop-down{width: 52px;                     border: none}# 下拉按钮图标                     QComboBox::down-arrow {border-image: url(.../向下.png);                       height:16px;                       width:12px}# 下面三项需要先设置下面代码self.QComboBox.currentIndexChanged.connect(self.main_info.usernamechange)self.QComboBox.setView(QListView())# 下拉框样式QListView{outline:0px}# 下拉框选项QListView::item{border-bottom:1px solid rgb(230, 230, 230, 1);                padding-left:2px;                font-size:12px;                font-weight:400;                color:rgba(51,51,51,1);                line-height:1px;                height:18px}# 下拉框选项鼠标悬停QListView::item::hover{background:rgba(245, 245, 254, 0.9)})</code></pre><h3 id="输入框"><a href="#输入框" class="headerlink" title="输入框"></a>输入框</h3><pre><code>QLineEdit{background:rgba(245,245,245,1);          border:1px solid rgba(30,159,255,1);          opacity:0.9;             border-radius:2px;          font-size:14px;          font-family:Microsoft YaHei;          font-weight:400;          color:rgba(134,134,134,1);          line-height:72px;          padding-left:15px}</code></pre><h3 id="滑块"><a href="#滑块" class="headerlink" title="滑块"></a>滑块</h3><pre><code># 滑块条QSlider::groove:horizontal{border:none;                           height:12px}# 以划过部分                           QSlider::sub-page:horizontal{background:rgba(0,191,255,0.5);                             border-radius:6px}# 未划过部分                             QSlider::add-page:horizontal{background:rgba(230,230,230,1);                             border-radius:6px}# 滑块                             QSlider::handle:horizontal{background:rgba(0,191,255,1);                           border:none;                           width:20px;                           height:20px;                           margin-top:-4px;                           margin-bottom:-4px;                           border-radius:10px}</code></pre><blockquote><p>本文用于记录我在工作中常用的控件样式表，后续还会继续更新。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>PyQt5</tag>
      
      <tag>样式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyQt5 自定义窗口标题栏, 实现窗口拖拽</title>
    <link href="/2020/02/13/PyQt5%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AA%97%E5%8F%A3%E6%A0%87%E9%A2%98%E6%A0%8F,%E5%AE%9E%E7%8E%B0%E7%AA%97%E5%8F%A3%E6%8B%96%E6%8B%BD/"/>
    <url>/2020/02/13/PyQt5%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AA%97%E5%8F%A3%E6%A0%87%E9%A2%98%E6%A0%8F,%E5%AE%9E%E7%8E%B0%E7%AA%97%E5%8F%A3%E6%8B%96%E6%8B%BD/</url>
    
    <content type="html"><![CDATA[<p>最近在使用pyqt5做窗口应用程序，因为原始的标题栏不能满足需求我们常常会使用到自定义的标题栏。<br>本篇放上一个最简单的例子提供参考</p><h2 id="隐藏原始标题栏"><a href="#隐藏原始标题栏" class="headerlink" title="隐藏原始标题栏"></a>隐藏原始标题栏</h2><pre><code>class test(QMainWindow):    def __init__(self):        super(test, self).__init__(None, Qt.FramelessWindowHint)  # 无边框设置        self.setFixedSize(880, 640)        self.setStyleSheet(&quot;QMainWindow{background:rgba(255,255,255,255)}&quot;)        self.init()</code></pre><blockquote><p>使用 Qt.FramelessWindowHint将我们的窗口设置为无边框窗口</p></blockquote><h2 id="创建一个标题栏"><a href="#创建一个标题栏" class="headerlink" title="创建一个标题栏"></a>创建一个标题栏</h2><pre><code>    def init(self):        # 创建一个标题栏        self.titlebar = QLabel(self)        self.titlebar.setFixedSize(880, 40)        self.titlebar.move(0, 0)        self.titlebar.setStyleSheet(&quot;QLabel{background:rgba(245,245,245,255)}&quot;)        # 图标        self.icon = QLabel(self)        self.icon.setFixedSize(20, 20)        self.icon.move(10, 10)        self.icon.setStyleSheet(&quot;QLabel{background-image: url(image/main_win/icon.png)}&quot;)        # 标题        self.title = QLabel(self)        self.title.setText(&#39;我的自定义标题栏&#39;)        self.title.move(37, 6)        self.title.setStyleSheet(&quot;QLabel{font-size:14px;&quot;                                 &quot;font-family:Microsoft YaHei;&quot;                                 &quot;font-weight:400;&quot;                                 &quot;color:rgba(51,51,51,1);&quot;                                 &quot;line-height:1px;&quot;)        # 关闭按钮        self.close_btn = QPushButton(self)        self.close_btn.setFixedSize(16, 16)        self.close_btn.move(842, 18)        self.close_btn.setStyleSheet(&quot;QPushButton{background-image: url(image/main_win/close.png);&quot;                                     &quot;border:none}&quot;)        self.close_btn.pressed.connect(self.close)        # # 最大化按钮        # self.max_btn = QPushButton(self)        # self.max_btn.setFixedSize(16, 16)        # self.max_btn.move(792, 18)        # self.max_btn.setStyleSheet(&quot;QPushButton{background-image: url(image/main_win/min.png);&quot;        #                            &quot;border:none}&quot;)        # self.max_btn.pressed.connect(self.ShowRestoreWindow)        # 最小化按钮        self.min_btn = QPushButton(self)        self.min_btn.setFixedSize(16, 16)        self.min_btn.move(742, 18)        self.min_btn.setStyleSheet(&quot;QPushButton{background-image: url(image/main_win/min.png);&quot;                                   &quot;border:none}&quot;)        self.min_btn.pressed.connect(self.showMinimized)    # def ShowRestoreWindow(self):    #     &quot;&quot;&quot;窗口最大化以及恢复&quot;&quot;&quot;    #     if self.isMaximized():    #         self.showNormal()    #     else:    #         self.showMaximized()    #     self.titleSize()    def mousePressEvent(self, QMouseEvent):        &quot;&quot;&quot;鼠标点击事件&quot;&quot;&quot;        if QMouseEvent.y() &lt; self.titlebar.height():  # 限制在标题栏区域内            self.startMovePos = QMouseEvent.globalPos()    def mouseMoveEvent(self, QMouseEvent):        &quot;&quot;&quot;鼠标拖拽事件&quot;&quot;&quot;        if QMouseEvent.y() &lt; self.titlebar.height():  # 限制在标题栏区域内            movePoint = QMouseEvent.globalPos() - self.startMovePos            widgetPos = self.pos()            self.startMovePos = QMouseEvent.globalPos()            self.move(widgetPos.x() + movePoint.x(), widgetPos.y() + movePoint.y())</code></pre><blockquote><p>这里我注释掉了最大化窗口事件，因为没有做好控件的自适应方案。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>PyQt5 应用</tag>
      
      <tag>自定义标题栏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客搭建及git部署</title>
    <link href="/2020/02/10/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8F%8Agit%E9%83%A8%E7%BD%B2/"/>
    <url>/2020/02/10/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8F%8Agit%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>本文用于记录我在创建hexo博客时的方法和步骤。<br>这是我第一次创建自己的博客，使用hexo主要是因为他的创建方法很简单，还可以通过git部署到公网。<br>这篇文章大部分参考了hexo的 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a> 所有内容在官方文档中都有更加详细的说明。</p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>Hexo 是一个快速、简洁且高效的博客框架。hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">官网</a></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>在你要存放博客的文件夹下使用命令窗口输入:</p><pre><code>$ npm install -g hexo-cli</code></pre><p>hexo是机遇 <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js</a> 的，所以在安装hexo之前我们需要先安装好Node.js<br>因为我们后面要使用git将我们的博客部署到公网所以也需要先把 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a> 安装好</p><blockquote><p>使用Node.js官方安装程序时，请确保勾选 Add to PATH 选项（默认已勾选）</p></blockquote><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><pre><code>$ hexo init$ npm install</code></pre><p>这个过程需要一些时间<br>创建好后会得到这样的文件结构</p><pre><code>.|——_config.yml  # 网站的配置信息|——package.json  # 应用程序信息|——scaffolds  # 模板文件夹|——source  # 资源文件夹|  |__ _posts  # 文章文件夹|__themes  # 主题文件夹</code></pre><p>我们可以在 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">_config.yml</a> 中修改大部分的配置<br>到这里我们的hexo博客就建好了，接下来就是将我们的博客部署到公网上了。</p><h2 id="博客部署到公网"><a href="#博客部署到公网" class="headerlink" title="博客部署到公网"></a>博客部署到公网</h2><p>关于如何将博客部署到公网，这里就要用到我们强大的git了。</p><p>首先我们需要在git上创建一个新仓库。</p><blockquote><p>注意: 仓库名必须是 [你的github用户名.github.io]</p></blockquote><p>然后我们需要生成ssh秘钥文件，因为Hexo部署在github上是通过密钥配对上传的。<br>Windows搜索打开Git Bash 输入</p><pre><code>git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot;ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;cd ~/.ssh</code></pre><p>Windows密钥文件在C:/Users/你的用户名/.ssh目录下。<br>打开git个人设置-SSH and GPG keys 页面- New SSH key 将刚刚复制的id_rsa.pub内容粘贴到key，最后点击Add SSH key。</p><h3 id="网站部署"><a href="#网站部署" class="headerlink" title="网站部署"></a>网站部署</h3><p>设置好git仓库后还需要修改hexo的配置文件，修改_config.yml</p><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: https://github.com/你的github用户名/你的github用户名.github.io.git  branch: master</code></pre><p>修改好后使用</p><pre><code>hexo d</code></pre><p>既可以在公网上通过 [你的github用户名.github.io] 看到你的个人博客啦。</p><h2 id="git同步管理"><a href="#git同步管理" class="headerlink" title="git同步管理"></a>git同步管理</h2><p>既然我们使用了git部署个人博客，那么能不能使用git来做博客的同步管理呢？<br>当然是可以的。<br>在博客根目录下打开Git Bassh</p><pre><code>git init #git初始化git remote add origin https://github.com/你的GitHub用户名/你的GitHub用户名.github.io.git #添加仓库地址git checkout -b 分支名 #新建分支并切换到新建的分支git add . #添加所有本地文件到gitgit commit -m &quot;这里填写你本次提交的备注&quot; #git提交git push origin 分支名 #文件推送到hexo分支</code></pre><p>比如这样：</p><pre><code>git init #git初始化git remote add origin https://github.com/xxx/xxx.github.io.git #添加仓库地址git checkout -b hexo #新建分支并切换到新建的分支git add . #添加所有本地文件到gitgit commit -m &quot;我的hexo同步文件&quot; #git提交git push origin hexo #文件推送到hexo分支</code></pre><p>这样就把博客项目上传到了git仓库的hexo分支下</p><h3 id="在另一台电脑下载博客工程"><a href="#在另一台电脑下载博客工程" class="headerlink" title="在另一台电脑下载博客工程"></a>在另一台电脑下载博客工程</h3><pre><code>git clone -b 分支名 https://github.com/你的GitHub用户/你的GitHub用户.github.io.git</code></pre><p>克隆下载完成后，进入到你项目的文件夹，配置你的hexo环境</p><pre><code>npm install -g hexo-cli #安装hexo,注意这里不需要hexo初始化,否则之前的hexo配置参数会重置npm install #安装依赖库npm install hexo-deployer-git #安装git部署相关配置</code></pre><blockquote><p>这里同样是要使用到ssh秘钥的，生成方式同上</p></blockquote><h3 id="文件的上传和更新"><a href="#文件的上传和更新" class="headerlink" title="文件的上传和更新"></a>文件的上传和更新</h3><pre><code>git add .git commit -m &quot;这里填写你本次提交的备注&quot;git push origin 分支名</code></pre><p>需要更新git上的项目文件时只需要执行上面的代码即可</p><p>同步只需要执行</p><pre><code>git pull</code></pre><p>到这我们不仅将博客部署到了公网上，还能够通过git进行同步管理啦。</p>]]></content>
    
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
      <tag>git同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/01/22/hello-world/"/>
    <url>/2020/01/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
