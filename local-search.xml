<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>python ftp上传与下载</title>
    <link href="/2020/04/26/python%20ftp%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"/>
    <url>/2020/04/26/python%20ftp%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><pre><code></code></pre><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>这里我们先封装一个继承至ftp的类，用于显示文件下载的进度。 这里我用到了QThread是应为我的项目使用了qt开发，而特意将下载过程放到子线程进行再使用qt的信号机制更新UI。</p><pre><code>from ftplib import FTPfrom PyQt5.QtCore import QThread, pyqtSignalhost = &#39;127.0.0.1&#39;port = 21username = &#39;xxx&#39;password = &#39;123456&#39;class ftpClient(FTP):    &quot;&quot;&quot;    cmd:命令    callback:回调函数    fsize:服务器中文件总大小    rest:已传送文件大小    &quot;&quot;&quot;    signal = None    def retrbinary(self, cmd, callback, fsize=0, rest=0):        cmpsize = rest        self.voidcmd(&#39;TYPE I&#39;)        # 此命令实现从指定位置开始下载,以达到续传的目的        conn = self.transfercmd(cmd, rest)        while 1:            try:                if fsize:                    if (fsize - cmpsize) &gt;= 1024:                        blocksize = 1024                    else:                        blocksize = fsize - cmpsize                    ret = float(cmpsize) / fsize                    num = ret * 100                    # 实现同一行打印下载进度                    # print(&#39;下载进度: %.2f%%&#39; % num)                    data = conn.recv(blocksize)                    if self.signal:                        if num &lt; 100:                            self.signal.emit(int(num), &#39;loading&#39;)                        else:                            self.signal.emit(int(num), &#39;true&#39;)                    if not data:                        break                    callback(data)                    cmpsize += len(data)            except Exception as e:                if self.signal:                    self.signal.emit(0, &#39;false&#39;)        conn.close()        return self.voidresp()class download(QThread):    &quot;&quot;&quot;    remote_path:目标地址    local_path:本地保存地址    &quot;&quot;&quot;    download_proess_signal = pyqtSignal(int, str)    def __init__(self, remote_path, local_path):        super(download, self).__init__()        self.remote_path = remote_path        self.local_path = local_path        self.ftp = ftpClient()        self.ftp.signal = self.download_proess_signal        self.ftp.connect(host, port)  # 第一个参数可以是ftp服务器的ip或者域名，第二个参数为ftp服务器的连接端口，默认为21        self.ftp.login(username, password)  # 匿名登录直接使用ftp.login()    def run(self):        &quot;&quot;&quot;下载ftp资源&quot;&quot;&quot;        fp = open(self.local_path, &quot;wb&quot;)        buf_size = self.ftp.size(self.remote_path)        self.ftp.retrbinary(&#39;RETR {}&#39;.format(self.remote_path), fp.write, buf_size)        fp.close()</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>ftp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pip 永久设置源</title>
    <link href="/2020/04/19/pip%20%E6%B0%B8%E4%B9%85%E8%AE%BE%E7%BD%AE%E6%BA%90/"/>
    <url>/2020/04/19/pip%20%E6%B0%B8%E4%B9%85%E8%AE%BE%E7%BD%AE%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a>清华源</h2><pre><code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python读取QQ邮箱邮件</title>
    <link href="/2020/04/19/python%E8%AF%BB%E5%8F%96QQ%E9%82%AE%E7%AE%B1%E9%82%AE%E4%BB%B6/"/>
    <url>/2020/04/19/python%E8%AF%BB%E5%8F%96QQ%E9%82%AE%E7%AE%B1%E9%82%AE%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>工作上遇到一个需要进行邮箱操作的需求，这里我以QQ邮箱为例记录下我的代码案例：</p><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><h3 id="首先引用我们需要的库"><a href="#首先引用我们需要的库" class="headerlink" title="首先引用我们需要的库"></a>首先引用我们需要的库</h3><pre><code>import poplibfrom email.parser import Parserfrom email.header import decode_headerfrom email.utils import parseaddr</code></pre><h3 id="然后是登录"><a href="#然后是登录" class="headerlink" title="然后是登录"></a>然后是登录</h3><pre><code>def login():    server = poplib.POP3_SSL(host_server)    # 可以打开或关闭调试信息:    # server.set_debuglevel(0)    # 可选:打印POP3服务器的欢迎文字:    # print(server.getwelcome().decode(&#39;utf-8&#39;))    # 身份认证:    server.user(&#39;username&#39;)    server.pass_(&#39;password&#39;)    return server</code></pre><blockquote><p>需要注意，应为我使用的是QQ邮箱所以这里的密码不是邮箱的登录密码，而是授权码。授权码需要在QQ邮箱中设置。[设置方式]（<a href="https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;no=308&amp;&amp;id=26）" target="_blank" rel="noopener">https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;no=308&amp;&amp;id=26）</a></p></blockquote><h3 id="获取邮箱中的右键列表"><a href="#获取邮箱中的右键列表" class="headerlink" title="获取邮箱中的右键列表"></a>获取邮箱中的右键列表</h3><pre><code>def getemaillist(server):    # server.stat()  # 返回邮件数量和占用空间:    resp, mails, octets = server.list()  # 返回所有邮件的编号:    # print(mails)  # 可以查看返回的列表类似[b&#39;1 82923&#39;, b&#39;2 2184&#39;, ...]    return mails</code></pre><h3 id="获取邮件内容"><a href="#获取邮件内容" class="headerlink" title="获取邮件内容"></a>获取邮件内容</h3><pre><code>def getEmail(server, index):    # index : 要获取的邮件    try:        resp, lines, octets = server.retr(index)        # lines存储了邮件的原始文本的每一行,        # 可以获得整个邮件的原始文本:        msg_content = b&#39;\r\n&#39;.join(lines).decode(&#39;utf-8&#39;)        # 稍后解析出邮件:        msg = Parser().parsestr(msg_content)        return print_info(msg)    except Exception as e:        return {}def print_info(msg, indent=0):    email_data = {}    if indent == 0:        for header in [&#39;From&#39;, &#39;To&#39;, &#39;Date&#39;, &#39;Subject&#39;]:            value = msg.get(header, &#39;&#39;)            if value:                if header == &#39;Subject&#39;:                    value = decode_str(value)                elif header == &#39;From&#39; or header == &#39;To&#39;:                    hdr, addr = parseaddr(value)                    name = decode_str(hdr)                    value = u&#39;%s &lt;%s&gt;&#39; % (name, addr)                elif header == &#39;Date&#39;:                    week, dt = GreenwichTime(value)                    value = dt.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)                    email_data[&#39;Week&#39;] = week            email_data[header] = value    if msg.is_multipart():        parts = msg.get_payload()        for n, part in enumerate(parts):            print_info(part, indent + 1)    else:        content_type = msg.get_content_type()        if content_type == &#39;text/plain&#39; or content_type == &#39;text/html&#39;:            content = msg.get_payload(decode=True)            charset = guess_charset(msg)            if charset:                content = content.decode(charset)            email_data[content_type] = content        else:            email_data[content_type] = content_type    return email_data</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>邮箱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyQt5 鼠标监听事件</title>
    <link href="/2020/04/12/PyQt5%20%E9%BC%A0%E6%A0%87%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6/"/>
    <url>/2020/04/12/PyQt5%20%E9%BC%A0%E6%A0%87%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>在PyQt的开发中常常会使用到鼠标监听，因此做一个记录。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>    def mousePressEvent(self, evt):        &quot;&quot;&quot;鼠标点击事件&quot;&quot;&quot;    def mouseDoubleClickEvent(self, *args, **kwargs):        &quot;&quot;&quot;鼠标双击事件&quot;&quot;&quot;    def enterEvent(self, *args, **kwargs):        &quot;&quot;&quot;鼠标进入事件&quot;&quot;&quot;    def leaveEvent(self, *args, **kwargs):        &quot;&quot;&quot;鼠标移除事件&quot;&quot;&quot;    def mouseMoveEvent(self, *args, **kwargs):        &quot;&quot;&quot;鼠标移动事件&quot;&quot;&quot;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>PyQt5</tag>
      
      <tag>鼠标监听</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyQt5使用QSplashScreen创建程序加载界面</title>
    <link href="/2020/04/05/PyQt5%E4%BD%BF%E7%94%A8QSplashScreen%E5%88%9B%E5%BB%BA%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E7%95%8C%E9%9D%A2/"/>
    <url>/2020/04/05/PyQt5%E4%BD%BF%E7%94%A8QSplashScreen%E5%88%9B%E5%BB%BA%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E7%95%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>由于Qt程序往往启动较慢，所以我们就需要一个启动界面来做缓冲。（没什么用的样子）</p><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><p>首先我们创建一个继承至QSplashScreen的类</p><pre><code>import timefrom PyQt5.QtCore import Qtfrom PyQt5.QtGui import QFont, QPixmapfrom PyQt5.QtWidgets import QSplashScreenclass SplashPanel(QSplashScreen):    def __init__(self):        super(SplashPanel, self).__init__()        message_font = QFont(&#39;Microsoft YaHei&#39;)        message_font.setBold(True)        message_font.setPointSize(12)        self.setFont(message_font)        pixmap = QPixmap(&#39;image/load.png&#39;)        self.setPixmap(pixmap)        self.show()        for i in range(1, 5):            self.showMessage(&#39;正在加载文件资源{}&#39;.format(&#39;.&#39; * i), alignment=Qt.AlignBottom, color=Qt.white)            time.sleep(0.15)    def mousePressEvent(self, evt):        pass        # 重写鼠标点击事件，阻止点击后消失    def mouseDoubleClickEvent(self, *args, **kwargs):        pass        # 重写鼠标移动事件，阻止出现卡顿现象    def enterEvent(self, *args, **kwargs):        pass        # 重写鼠标移动事件，阻止出现卡顿现象    def mouseMoveEvent(self, *args, **kwargs):        pass        # 重写鼠标移动事件，阻止出现卡顿现象</code></pre><p>然后是我们的启动函数</p><pre><code>if __name__ == &quot;__main__&quot;:    app = QApplication(sys.argv)    splash = SplashPanel()    app.processEvents()  # 不阻塞程序    myWin = my_win()    splash.finish(myWin)    splash.deleteLater()    myWin.show()    sys.exit(win.exec_())</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>PyQt5</tag>
      
      <tag>QSplashScreen</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用QtWebEngineWidgets下载网页资源</title>
    <link href="/2020/04/05/%E4%BD%BF%E7%94%A8QtWebEngineWidgets%E4%B8%8B%E8%BD%BD%E7%BD%91%E9%A1%B5%E8%B5%84%E6%BA%90/"/>
    <url>/2020/04/05/%E4%BD%BF%E7%94%A8QtWebEngineWidgets%E4%B8%8B%E8%BD%BD%E7%BD%91%E9%A1%B5%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><pre><code>    def __init__(self):        super(my_Browser, self).__init__(None)        self.page().profile().downloadRequested.connect(self.on_downloadRequested)  # 页面下载请求    def on_downloadRequested(self, downloadItem):        if downloadItem.isFinished() == False and downloadItem.state() == 0:            ###生成文件存储地址            the_filename = downloadItem.url().fileName()            the_sourceFile = os.path.join(&#39;D:\\&#39;, the_filename)            ###下载文件            downloadItem.setPath(the_sourceFile)            downloadItem.accept()            downloadItem.finished.connect(self.on_downloadfinished)        #  下载结束触发函数    def on_downloadfinished(self):        js_string = &#39;&#39;&#39;               alert(&quot;下载成功，请到软件同目录下，查找下载文件！&quot;);               &#39;&#39;&#39;        self.page().runJavaScript(js_string)</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>PyQt5</tag>
      
      <tag>QtWebEngineWidgets</tag>
      
      <tag>Web浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyQt5 QThread使用</title>
    <link href="/2020/03/29/PyQt5%20QThread%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/03/29/PyQt5%20QThread%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>在使用PyQt进行开发时，我们常常会使用线程来将部分逻辑代码与界面主线程分离。<br>这时我们一般会使用Python的threading模块来实现，但是这个模块在某些情况下会导致UI界面卡死（可能是我使用方法不对），所以我更推荐使用QThread来进行多线程操作。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>这里我们创建一个继承至QThread的类。</p><pre><code>class myThread(QThread):    pyqtsignal = pyqtSignal()    def __init__(self):        super(myThread, self).__init__()        &quot;&quot;&quot;初始化线程&quot;&quot;&quot;    def run(self):        try:            &quot;&quot;&quot;这里是我们要进行的耗时操作&quot;&quot;&quot;            self.pyqtsignal.emit()  # 发送信号            self.exit(0)  # 关闭线程        except Exception as e:            print(e)            self.exit(0)</code></pre><blockquote><p>这里要注意QThread中的信号只能通过pyqtSignal信号槽的方式来传递。</p></blockquote><p>调用很简单</p><pre><code>myt = myThread()myt.pyqtsignal.connect(...)myt.start()</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>PyQt5</tag>
      
      <tag>QThread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python调用 C# Dll</title>
    <link href="/2020/03/22/python%E8%B0%83%E7%94%A8%20C#%20Dll/"/>
    <url>/2020/03/22/python%E8%B0%83%E7%94%A8%20C#%20Dll/</url>
    
    <content type="html"><![CDATA[<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://blog.csdn.net/LTG01/article/details/80700513" target="_blank" rel="noopener">参考</a></p><pre><code>import clr  #clr是公共运行时环境，这个模块是与C#交互的核心clr.FindAssembly(&quot;PythonNetTest.dll&quot;) ## 加载c#dll文件from PythonNetTest import *    # 导入命名空间instance = Class1() #class1是dll里面的类print(instance.AddShort(2, 3))#一个简单的加法</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>C# Dll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>获取QtWebEngine的Cookie信息</title>
    <link href="/2020/03/22/%E8%8E%B7%E5%8F%96QtWebEngine%E7%9A%84Cookie%E4%BF%A1%E6%81%AF/"/>
    <url>/2020/03/22/%E8%8E%B7%E5%8F%96QtWebEngine%E7%9A%84Cookie%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://mali-mali.github.io/2020/03/02/%E4%BD%BF%E7%94%A8QtWebEngineWidgets%E5%BC%80%E5%8F%91Web%E6%B5%8F%E8%A7%88%E5%99%A8/" target="_blank" rel="noopener">之前</a>我们使用QtWebEngine创建了一个浏览器，并且为这个浏览器添加了cookie信息，那么我们有没有可能需要的是浏览器的cookie信息呢？</p><h2 id="获取QtWebEngine浏览器Cookie信息"><a href="#获取QtWebEngine浏览器Cookie信息" class="headerlink" title="获取QtWebEngine浏览器Cookie信息"></a>获取QtWebEngine浏览器Cookie信息</h2><p>在构造函数中添加如下代码</p><pre><code>    ...    def __init__(self, parent=None):        super().__init__(parent)        ...        QWebEngineProfile.defaultProfile().cookieStore().cookieAdded.connect(self.onCookieAdd)        self.cookies = {}  # 存放cookie字典    ...</code></pre><p>接下来添加两个函数</p><pre><code>    def onCookieAdd(self, cookie):  # 处理cookie添加的事件        print(cookie)        name = cookie.name().data().decode(&#39;utf-8&#39;)  # 先获取cookie的名字，再把编码处理一下        value = cookie.value().data().decode(&#39;utf-8&#39;)  # 先获取cookie值，再把编码处理一下        self.cookies[name] = value  # 将cookie保存到字典里    # 获取cookie    def get_cookie(self):        print(self.cookies.items())        # cookie_str = &#39;&#39;        # for key, value in self.cookies.items():  # 遍历字典        #     cookie_str += (key + &#39;=&#39; + value + &#39;;&#39;)  # 将键值对拿出来拼接一下        return dict(self.cookies.items())  # 返回拼接好的字符串</code></pre><p>这时我们会获取的一些不需要的cookie信息，提取一下</p><pre><code>cookie = &#39;JSESSIONID=&#39; + self.get_cookie().get(&#39;JSESSIONID&#39;, &#39;&#39;)</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>QtWebEngine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask用户管理</title>
    <link href="/2020/03/15/Flask%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <url>/2020/03/15/Flask%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://mali-mali.github.io/2020/03/07/%E4%BD%BF%E7%94%A8Flask%E5%88%9B%E5%BB%BApython%20http%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">上一篇</a> 中，我们使用了Flask创建了一个python的http后台服务，<br>今天我们来讲讲如何在其中实现用户的登录管理。</p><h2 id="api初始化"><a href="#api初始化" class="headerlink" title="api初始化"></a>api初始化</h2><p>首先同样的初始化我们的api</p><pre><code>from flask import Flaskfrom flask_login import LoginManagerfrom flask_migrate import Migratefrom flask_sqlalchemy import SQLAlchemydb = SQLAlchemy()login_manager = LoginManager()login_manager.session_protection = &#39;strong&#39;def start_aip(config_name, collection=None):    &quot;&quot;&quot;    初始化API    :param config_name:    :param collection:    :return:    &quot;&quot;&quot;    app = Flask(__name__)    db.init_app(app)    Migrate(app, db)    login_manager.init_app(app)    from test.my_info import api    api.init_app(app, version=&#39;1.0&#39;, title=&#39;API&#39;, description=&#39;A test API&#39;)    return app</code></pre><h2 id="登录验证"><a href="#登录验证" class="headerlink" title="登录验证"></a>登录验证</h2><p>这里创建一个User.py</p><pre><code>import timeimport functoolsfrom datetime import datetimefrom flask import jsonify, requestfrom flask_login import UserMixinfrom itsdangerous import TimedJSONWebSignatureSerializer as Serializerfrom werkzeug.security import generate_password_hash, check_password_hashfrom config import settingsfrom ..models.error import unauthorized, forbiddenfrom .. import dbfrom .. import login_managerclass User(UserMixin, db.Model):    &quot;&quot;&quot;    用户表    :param: UserMixin    :param: db.Model    :return:    &quot;&quot;&quot;    __tablename__ = &#39;users&#39;    id = db.Column(db.Integer, primary_key=True)    email = db.Column(db.String(64), unique=True, index=True)    username = db.Column(db.String(64), unique=True, index=True)    password_hash = db.Column(db.String(128))    confirmed = db.Column(db.Boolean, default=False)    name = db.Column(db.String(64))    location = db.Column(db.String(64))    about_me = db.Column(db.Text())    member_since = db.Column(db.DateTime(), default=datetime.utcnow)    last_seen = db.Column(db.DateTime(), default=datetime.utcnow)    avatar_hash = db.Column(db.String(32))    tokenTime = time.mktime(datetime.now().timetuple())    def generate_auth_token(self, expiration):        &quot;&quot;&quot;        生成token        :return:        &quot;&quot;&quot;        s = Serializer(settings.Config.SECRET_KEY, expires_in=expiration)        token = s.dumps({&#39;id&#39;: self.id}).decode(&#39;ascii&#39;)        return token    def verify_password(self, password):        return check_password_hash(self.password_hash, password)@login_manager.user_loaderdef load_user(user_id):    return User.query.get(int(user_id))def login_required(view_func):    @functools.wraps(view_func)    def verify_token(*args, **kwargs):        try:            # 在请求头上拿到token            token = request.headers[&quot;token&quot;]        except Exception:            # 没接收的到token,给前端抛出错误            return forbidden(&#39;缺少参数token&#39;)        s = Serializer(settings.Config.SECRET_KEY)        try:            s.loads(token)        except Exception:            # print(&quot;验证失败, 无效的token&quot;)            return unauthorized(&#39;验证失败, 无效的token&#39;)        return view_func(*args, **kwargs)    return verify_token</code></pre><h2 id="接口及其他"><a href="#接口及其他" class="headerlink" title="接口及其他"></a>接口及其他</h2><p>最后我们只需要建立我们的登录接口即可</p><pre><code>upload_parser = reqparse.RequestParser()upload_parser.add_argument(&#39;token&#39;, type=str, location=&#39;headers&#39;)user = api.namespace(&#39;Login&#39;, path=&#39;/&#39;, description=&#39;hello world&#39;)## 应为我们之前使用了swagger在线api这里需要编辑请求时需要传递的参数（可以忽略）login_model = smart_tax.api.model(&#39;Login&#39;, {    &#39;username&#39;: fields.String(description=&#39;用户名, 默认:admin&#39;),    &#39;password&#39;: fields.String(description=&#39;密码, 默认:yiyetong123&#39;)})@user.route(&#39;/login&#39;)class login(Resource):    &quot;&quot;&quot;    登录：    &quot;&quot;&quot;    @user.expect(login_model)    def post(self):        &#39;&#39;&#39;登录&#39;&#39;&#39;        username = api.payload.get(&#39;username&#39;, None)        password = api.payload.get(&#39;password&#39;, None)        user = User.query.filter_by(username=username).first()        if user is not None and user.verify_password(password):            login_user(user)            return jsonify({&#39;code&#39;: 200, &#39;token&#39;: user.generate_auth_token(tokenExpiration), &#39;expiration&#39;: tokenExpiration})        else:            return unauthorized(&#39;Invalid username or password.&#39;)    # def get(self):    #     &#39;&#39;&#39;验证失败自动跳转&#39;&#39;&#39;    #     return unauthorized(&#39;Unauthorized.&#39;)@user.route(&#39;/logout&#39;)class logout(Resource):    &quot;&quot;&quot;    登出    &quot;&quot;&quot;    @login_required    @user.expect(upload_parser)    def get(self):        &#39;&#39;&#39;登出&#39;&#39;&#39;        logout_user()        logoutMessage = {&quot;message&quot;: &#39;You have been logged out.&#39;}        flash(logoutMessage)        return jsonify(logoutMessage)</code></pre><blockquote><p>在需要进行登录校验的接口上添加 @login_required 后该接口必须输入登入时返回的token信息才可访问， @user.expect(upload_parser) 为swagger在线api的装饰器。</p></blockquote><h3 id="自定义错误信息"><a href="#自定义错误信息" class="headerlink" title="自定义错误信息"></a>自定义错误信息</h3><pre><code>def bad_request(message):    &quot;&quot;&quot;    服务器不理解客户端的请求，未做任何处理。    :param message:    :return:    &quot;&quot;&quot;    return {&#39;code&#39;: 400, &#39;message&#39;: message, &#39;data&#39;: None}def unauthorized(message):    &quot;&quot;&quot;    用户未提供身份验证凭据，或者没有通过身份验证。    :param message:    :return:    &quot;&quot;&quot;    return {&#39;code&#39;: 401, &#39;message&#39;: message, &#39;data&#39;: None}    # return plugin.api.abort(code=200, message=message)def forbidden(message):    &quot;&quot;&quot;    用户通过了身份验证，但是不具有访问资源所需的权限。    :param message:    :return:    &quot;&quot;&quot;    return {&#39;code&#39;: 403, &#39;message&#39;: message, &#39;data&#39;: None}def NotFound(message):    &quot;&quot;&quot;    :param message:    :return:    &quot;&quot;&quot;    return {&#39;code&#39;: 404, &#39;message&#39;: message, &#39;data&#39;: None}def NotFoundDevice(message):    &quot;&quot;&quot;    :param message:    :return:    &quot;&quot;&quot;    return {&#39;code&#39;: 412, &#39;message&#39;: message, &#39;data&#39;: None}def internalServerError(message):    &quot;&quot;&quot;    :param message:    :return:    &quot;&quot;&quot;    return {&#39;code&#39;: 500, &#39;message&#39;: message, &#39;data&#39;: None}def deviceTimeoutError(message):    &quot;&quot;&quot;    :param message:    :return:    &quot;&quot;&quot;    return {&#39;code&#39;: 501, &#39;message&#39;: message, &#39;data&#39;: None}def parameterError(message):    &quot;&quot;&quot;    :param message:    :return:    &quot;&quot;&quot;    return {&#39;code&#39;: 502, &#39;message&#39;: message, &#39;data&#39;: None}def successful(data):    &quot;&quot;&quot;    成功    :param data:    :return:    &quot;&quot;&quot;    return {&#39;code&#39;: 200, &#39;message&#39;: None, &#39;data&#39;: data}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>flask</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QWebEngineView与网页JS进行交互 忽略网页SSL证书错误</title>
    <link href="/2020/03/10/QWebEngineView%E4%B8%8E%E7%BD%91%E9%A1%B5JS%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92%20%E5%BF%BD%E7%95%A5%E7%BD%91%E9%A1%B5SSL%E8%AF%81%E4%B9%A6%E9%94%99%E8%AF%AF/"/>
    <url>/2020/03/10/QWebEngineView%E4%B8%8E%E7%BD%91%E9%A1%B5JS%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92%20%E5%BF%BD%E7%95%A5%E7%BD%91%E9%A1%B5SSL%E8%AF%81%E4%B9%A6%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<p>之前我们讲到了使用QtWebEngineWidgets模块开发一个内嵌webview的Qt5客户端界面。竟然我们使用了内嵌式的webview那就免不了要与网页JS代码进行一些交互，今天我们就说说如何使我们的python程序与网页JS进行交互。</p><h2 id="QWebEngineView与网页JS进行交互"><a href="#QWebEngineView与网页JS进行交互" class="headerlink" title="QWebEngineView与网页JS进行交互"></a>QWebEngineView与网页JS进行交互</h2><p>这里我们需要先用到PyQt5.QtWebChannel，并且重写一个我们的webview类，继承至QWebEngineView. <a href="https://blog.csdn.net/kaida1234/article/details/80422704" target="_blank" rel="noopener">参考</a></p><pre><code>from PyQt5.QtWebEngineWidgets import QWebEngineViewfrom PyQt5.QtCore import QObject, pyqtSignal, pyqtSlotfrom PyQt5.QtWebChannel import QWebChannelclass My_Browser(QWebEngineView):    SigSendMessageToJS = pyqtSignal(str)    def __init__(self, parent):        super().__init__(parent)        self.pWebChannel = QWebChannel(self.page())        self.pInteractObj = TInteractObj(self)        self.pWebChannel.registerObject(&quot;interactObj&quot;, self.pInteractObj)        self.page().setWebChannel(self.pWebChannel)        self.pInteractObj.SigReceivedMessFromJS.connect(self.OnReceiveMessageFromJS)        self.SigSendMessageToJS.connect(self.pInteractObj.SigSendMessageToJS)    def OnReceiveMessageFromJS(self, strParameter):        print(&#39;OnReceiveMessageFromJS()&#39;)        if not strParameter:            return        print(&#39;FromJS Messiage:&#39; + strParameter)    def OnSendMessageByInteractObj(self, strMessage):        if not strMessage:            return        self.SigSendMessageToJS.emit(strMessage)class TInteractObj(QObject):    SigReceivedMessFromJS = pyqtSignal(str)    SigSendMessageToJS = pyqtSignal(str)    def __init__(self, parent=None):        super().__init__(parent)    @pyqtSlot(str)    def JSSendMessage(self, strParameter):        print(&#39;JSSendMessage(%s) from Html&#39; % strParameter)        self.SigReceivedMessFromJS.emit(strParameter)    @pyqtSlot(result=str)    def fun(self):        print(&#39;TInteractObj.fun()&#39;)        return &#39;hello&#39;</code></pre><blockquote><p>这里TInteractObj类需要继承至QObject</p></blockquote><h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><pre><code>&lt;!DOCTYPE html&gt;  &lt;html&gt;      &lt;head&gt;          &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;          &lt;script type=&quot;text/javascript&quot; src=&quot;./qwebchannel.js&quot;&gt;&lt;/script&gt;          &lt;script type=&quot;text/javascript&quot;&gt;          //---Web show receive message---        function output(message)          {              var output = document.getElementById(&quot;output&quot;);              output.innerHTML = output.innerHTML + message + &quot;\n&quot;;          }          function showAlert()         {            alert(&#39;this is web alert&#39;);        }        //Web initial loading          window.onload = function()          {            new QWebChannel(qt.webChannelTransport, function(channel)             {                //Get Qt interact object                  var interactObj = channel.objects.interactObj;                 //Web send message to Qt                 document.getElementById(&quot;send&quot;).onclick = function()                 {                    var input = document.getElementById(&quot;input&quot;);                    if (!input.value)                     {                          return;                      }                      output(&quot;Send string to Qt: &quot; + input.value);                      //Web use the interface of Qt                     // interactObj.fun(alert);                    interactObj.JSSendMessage(input.value);                      input.value = &quot;&quot;;                                      }                  //Web connect the Qt signal, then Qt can call &quot;output&quot; function                interactObj.SigSendMessageToJS.connect(function(str)                {                      output(&quot;Received string from Qt: &quot; + str);                  });            });          }          &lt;/script&gt;          &lt;style type=&quot;text/css&quot;&gt;              html {                  height: 100%;                  width: 100%;              }              #input {                  width: 650px;                  margin: 0 10px 0 0;              }              #send {                  width: 90px;                  margin: 0;              }              #output {                  width: 770px;                  height: 550px;              }          &lt;/style&gt;      &lt;/head&gt;      &lt;body&gt;          &lt;textarea id=&quot;output&quot; readonly=&quot;readonly&quot;&gt;&lt;/textarea&gt;&lt;br /&gt;          &lt;input id=&quot;input&quot; /&gt;          &lt;input type=&quot;submit&quot; id=&quot;send&quot; value=&quot;Send&quot; οnclick=&quot;javascript:click();&quot; /&gt;      &lt;/body&gt;  &lt;/html&gt;</code></pre><blockquote><p>这里有一些需要注意的地方是js中定义的槽函数名需要和python中定义的一致，否则是无效的。</p></blockquote><h3 id="qwebchannel-js"><a href="#qwebchannel-js" class="headerlink" title="qwebchannel.js"></a>qwebchannel.js</h3><p>另外我们还需要一个qwebchannel.js脚本，使用时需要在html中引用</p><pre><code>/******************************************************************************** Copyright (C) 2016 The Qt Company Ltd.** Contact: http://www.qt.io/licensing/**** This file is part of the examples of the Qt Toolkit.**** $QT_BEGIN_LICENSE:BSD$** You may use this file under the terms of the BSD license as follows:**** &quot;Redistribution and use in source and binary forms, with or without** modification, are permitted provided that the following conditions are** met:**   * Redistributions of source code must retain the above copyright**     notice, this list of conditions and the following disclaimer.**   * Redistributions in binary form must reproduce the above copyright**     notice, this list of conditions and the following disclaimer in**     the documentation and/or other materials provided with the**     distribution.**   * Neither the name of The Qt Company Ltd nor the names of its**     contributors may be used to endorse or promote products derived**     from this software without specific prior written permission.****** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;**** $QT_END_LICENSE$******************************************************************************/&quot;use strict&quot;;var QWebChannelMessageTypes = {    signal: 1,    propertyUpdate: 2,    init: 3,    idle: 4,    debug: 5,    invokeMethod: 6,    connectToSignal: 7,    disconnectFromSignal: 8,    setProperty: 9,    response: 10,};var QWebChannel = function(transport, initCallback){    if (typeof transport !== &quot;object&quot; || typeof transport.send !== &quot;function&quot;) {        console.error(&quot;The QWebChannel expects a transport object with a send function and onmessage callback property.&quot; +                      &quot; Given is: transport: &quot; + typeof(transport) + &quot;, transport.send: &quot; + typeof(transport.send));        return;    }    var channel = this;    this.transport = transport;    this.send = function(data)    {        if (typeof(data) !== &quot;string&quot;) {            data = JSON.stringify(data);        }        channel.transport.send(data);    }    this.transport.onmessage = function(message)    {        var data = message.data;        if (typeof data === &quot;string&quot;) {            data = JSON.parse(data);        }        switch (data.type) {            case QWebChannelMessageTypes.signal:                channel.handleSignal(data);                break;            case QWebChannelMessageTypes.response:                channel.handleResponse(data);                break;            case QWebChannelMessageTypes.propertyUpdate:                channel.handlePropertyUpdate(data);                break;            default:                console.error(&quot;invalid message received:&quot;, message.data);                break;        }    }    this.execCallbacks = {};    this.execId = 0;    this.exec = function(data, callback)    {        if (!callback) {            // if no callback is given, send directly            channel.send(data);            return;        }        if (channel.execId === Number.MAX_VALUE) {            // wrap            channel.execId = Number.MIN_VALUE;        }        if (data.hasOwnProperty(&quot;id&quot;)) {            console.error(&quot;Cannot exec message with property id: &quot; + JSON.stringify(data));            return;        }        data.id = channel.execId++;        channel.execCallbacks[data.id] = callback;        channel.send(data);    };    this.objects = {};    this.handleSignal = function(message)    {        var object = channel.objects[message.object];        if (object) {            object.signalEmitted(message.signal, message.args);        } else {            console.warn(&quot;Unhandled signal: &quot; + message.object + &quot;::&quot; + message.signal);        }    }    this.handleResponse = function(message)    {        if (!message.hasOwnProperty(&quot;id&quot;)) {            console.error(&quot;Invalid response message received: &quot;, JSON.stringify(message));            return;        }        channel.execCallbacks[message.id](message.data);        delete channel.execCallbacks[message.id];    }    this.handlePropertyUpdate = function(message)    {        for (var i in message.data) {            var data = message.data[i];            var object = channel.objects[data.object];            if (object) {                object.propertyUpdate(data.signals, data.properties);            } else {                console.warn(&quot;Unhandled property update: &quot; + data.object + &quot;::&quot; + data.signal);            }        }        channel.exec({type: QWebChannelMessageTypes.idle});    }    this.debug = function(message)    {        channel.send({type: QWebChannelMessageTypes.debug, data: message});    };    channel.exec({type: QWebChannelMessageTypes.init}, function(data) {        for (var objectName in data) {            var object = new QObject(objectName, data[objectName], channel);        }        // now unwrap properties, which might reference other registered objects        for (var objectName in channel.objects) {            channel.objects[objectName].unwrapProperties();        }        if (initCallback) {            initCallback(channel);        }        channel.exec({type: QWebChannelMessageTypes.idle});    });};function QObject(name, data, webChannel){    this.__id__ = name;    webChannel.objects[name] = this;    // List of callbacks that get invoked upon signal emission    this.__objectSignals__ = {};    // Cache of all properties, updated when a notify signal is emitted    this.__propertyCache__ = {};    var object = this;    // ----------------------------------------------------------------------    this.unwrapQObject = function(response)    {        if (response instanceof Array) {            // support list of objects            var ret = new Array(response.length);            for (var i = 0; i &lt; response.length; ++i) {                ret[i] = object.unwrapQObject(response[i]);            }            return ret;        }        if (!response            || !response[&quot;__QObject*__&quot;]            || response.id === undefined) {            return response;        }        var objectId = response.id;        if (webChannel.objects[objectId])            return webChannel.objects[objectId];        if (!response.data) {            console.error(&quot;Cannot unwrap unknown QObject &quot; + objectId + &quot; without data.&quot;);            return;        }        var qObject = new QObject( objectId, response.data, webChannel );        qObject.destroyed.connect(function() {            if (webChannel.objects[objectId] === qObject) {                delete webChannel.objects[objectId];                // reset the now deleted QObject to an empty {} object                // just assigning {} though would not have the desired effect, but the                // below also ensures all external references will see the empty map                // NOTE: this detour is necessary to workaround QTBUG-40021                var propertyNames = [];                for (var propertyName in qObject) {                    propertyNames.push(propertyName);                }                for (var idx in propertyNames) {                    delete qObject[propertyNames[idx]];                }            }        });        // here we are already initialized, and thus must directly unwrap the properties        qObject.unwrapProperties();        return qObject;    }    this.unwrapProperties = function()    {        for (var propertyIdx in object.__propertyCache__) {            object.__propertyCache__[propertyIdx] = object.unwrapQObject(object.__propertyCache__[propertyIdx]);        }    }    function addSignal(signalData, isPropertyNotifySignal)    {        var signalName = signalData[0];        var signalIndex = signalData[1];        object[signalName] = {            connect: function(callback) {                if (typeof(callback) !== &quot;function&quot;) {                    console.error(&quot;Bad callback given to connect to signal &quot; + signalName);                    return;                }                object.__objectSignals__[signalIndex] = object.__objectSignals__[signalIndex] || [];                object.__objectSignals__[signalIndex].push(callback);                if (!isPropertyNotifySignal &amp;&amp; signalName !== &quot;destroyed&quot;) {                    // only required for &quot;pure&quot; signals, handled separately for properties in propertyUpdate                    // also note that we always get notified about the destroyed signal                    webChannel.exec({                        type: QWebChannelMessageTypes.connectToSignal,                        object: object.__id__,                        signal: signalIndex                    });                }            },            disconnect: function(callback) {                if (typeof(callback) !== &quot;function&quot;) {                    console.error(&quot;Bad callback given to disconnect from signal &quot; + signalName);                    return;                }                object.__objectSignals__[signalIndex] = object.__objectSignals__[signalIndex] || [];                var idx = object.__objectSignals__[signalIndex].indexOf(callback);                if (idx === -1) {                    console.error(&quot;Cannot find connection of signal &quot; + signalName + &quot; to &quot; + callback.name);                    return;                }                object.__objectSignals__[signalIndex].splice(idx, 1);                if (!isPropertyNotifySignal &amp;&amp; object.__objectSignals__[signalIndex].length === 0) {                    // only required for &quot;pure&quot; signals, handled separately for properties in propertyUpdate                    webChannel.exec({                        type: QWebChannelMessageTypes.disconnectFromSignal,                        object: object.__id__,                        signal: signalIndex                    });                }            }        };    }    /**     * Invokes all callbacks for the given signalname. Also works for property notify callbacks.     */    function invokeSignalCallbacks(signalName, signalArgs)    {        var connections = object.__objectSignals__[signalName];        if (connections) {            connections.forEach(function(callback) {                callback.apply(callback, signalArgs);            });        }    }    this.propertyUpdate = function(signals, propertyMap)    {        // update property cache        for (var propertyIndex in propertyMap) {            var propertyValue = propertyMap[propertyIndex];            object.__propertyCache__[propertyIndex] = propertyValue;        }        for (var signalName in signals) {            // Invoke all callbacks, as signalEmitted() does not. This ensures the            // property cache is updated before the callbacks are invoked.            invokeSignalCallbacks(signalName, signals[signalName]);        }    }    this.signalEmitted = function(signalName, signalArgs)    {        invokeSignalCallbacks(signalName, signalArgs);    }    function addMethod(methodData)    {        var methodName = methodData[0];        var methodIdx = methodData[1];        object[methodName] = function() {            var args = [];            var callback;            for (var i = 0; i &lt; arguments.length; ++i) {                if (typeof arguments[i] === &quot;function&quot;)                    callback = arguments[i];                else                    args.push(arguments[i]);            }            webChannel.exec({                &quot;type&quot;: QWebChannelMessageTypes.invokeMethod,                &quot;object&quot;: object.__id__,                &quot;method&quot;: methodIdx,                &quot;args&quot;: args            }, function(response) {                if (response !== undefined) {                    var result = object.unwrapQObject(response);                    if (callback) {                        (callback)(result);                    }                }            });        };    }    function bindGetterSetter(propertyInfo)    {        var propertyIndex = propertyInfo[0];        var propertyName = propertyInfo[1];        var notifySignalData = propertyInfo[2];        // initialize property cache with current value        // NOTE: if this is an object, it is not directly unwrapped as it might        // reference other QObject that we do not know yet        object.__propertyCache__[propertyIndex] = propertyInfo[3];        if (notifySignalData) {            if (notifySignalData[0] === 1) {                // signal name is optimized away, reconstruct the actual name                notifySignalData[0] = propertyName + &quot;Changed&quot;;            }            addSignal(notifySignalData, true);        }        Object.defineProperty(object, propertyName, {            configurable: true,            get: function () {                var propertyValue = object.__propertyCache__[propertyIndex];                if (propertyValue === undefined) {                    // This shouldn&#39;t happen                    console.warn(&quot;Undefined value in property cache for property \&quot;&quot; + propertyName + &quot;\&quot; in object &quot; + object.__id__);                }                return propertyValue;            },            set: function(value) {                if (value === undefined) {                    console.warn(&quot;Property setter for &quot; + propertyName + &quot; called with undefined value!&quot;);                    return;                }                object.__propertyCache__[propertyIndex] = value;                webChannel.exec({                    &quot;type&quot;: QWebChannelMessageTypes.setProperty,                    &quot;object&quot;: object.__id__,                    &quot;property&quot;: propertyIndex,                    &quot;value&quot;: value                });            }        });    }    // ----------------------------------------------------------------------    data.methods.forEach(addMethod);    data.properties.forEach(bindGetterSetter);    data.signals.forEach(function(signal) { addSignal(signal, false); });    for (var name in data.enums) {        object[name] = data.enums[name];    }}//required for use with nodejsif (typeof module === &#39;object&#39;) {    module.exports = {        QWebChannel: QWebChannel    };}</code></pre><h2 id="忽略网页SSL证书错误"><a href="#忽略网页SSL证书错误" class="headerlink" title="忽略网页SSL证书错误"></a>忽略网页SSL证书错误</h2><p>另外在使用中，当我们打开一些特定网页是会存在SSL错误，而导致QWebEngineView无法打开网页。<br>跳过的方法很简单，只需要重写一下QWebEnginePage.certificateError() 这个函数即可。<a href="https://blog.csdn.net/zencher/article/details/79558919" target="_blank" rel="noopener">参考</a></p><pre><code>from PyQt5.QtWebEngineWidgets import QWebEnginePage...class CustomWebEnginePage(QWebEnginePage):    def certificateError(self, error):        return True</code></pre><p>然后我们在上面My_Browser.<strong>init</strong>()中添加</p><pre><code>        self.setPage(CustomWebEnginePage(self))</code></pre><p>这样即可顺利的忽略SSL错误了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>QWebEngineView</tag>
      
      <tag>SSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Flask创建python http框架</title>
    <link href="/2020/03/07/%E4%BD%BF%E7%94%A8Flask%E5%88%9B%E5%BB%BApython%20http%E6%A1%86%E6%9E%B6/"/>
    <url>/2020/03/07/%E4%BD%BF%E7%94%A8Flask%E5%88%9B%E5%BB%BApython%20http%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>在python中，我们可以很方便的通过flask这个框架来创建一个http的后台服务。还可以通过flask_restplus快速创建一个swagger在线api文档。</p><h2 id="http服务创建"><a href="#http服务创建" class="headerlink" title="http服务创建"></a>http服务创建</h2><p>先来一个简单的 hello world</p><pre><code>#!/usr/bin/env python# -*- coding: utf-8 -*-from flask import Flaskapp = Flask(__name__)@app.route(&#39;/hello&#39;)def helloworld():    return &#39;hello world&#39;if __name__ == &quot;__main__&quot;:    app.run(host=&#39;127.0.0.1&#39;, port=7777, debug=False, threaded=True)</code></pre><h2 id="生成swagger在线api文档"><a href="#生成swagger在线api文档" class="headerlink" title="生成swagger在线api文档"></a>生成swagger在线api文档</h2><p>通常我们都会使用Postman来进行接口的测试，但是多人项目中Postman就有些不方便了。<br>为了方便接口的测试，我们来创建一个swagger在线api文档</p><h3 id="init-py"><a href="#init-py" class="headerlink" title="init.py"></a><strong>init</strong>.py</h3><pre><code>#!/usr/bin/env python# -*- coding: utf-8 -*-from flask_restplus import Api, reqparseapi = Api()hello = api.namespace(&#39;Hello&#39;, path=&#39;/&#39;, description=&#39;hello world&#39;)from . import info</code></pre><blockquote><p>新建一个存放接口代码的文件夹my_info，在<strong>init</strong>.py中输入上面的代码，再在这个目录下创建一个info.py用于存放接口代码。</p></blockquote><h3 id="info-py"><a href="#info-py" class="headerlink" title="info.py"></a>info.py</h3><pre><code>#!/usr/bin/env python# -*- coding: utf-8 -*-from ..my_info import api, hellofrom flask_restplus import Resourcefrom flask_restplus import fieldshello_model = api.model(&#39;hello&#39;, {    &#39;text&#39;: fields.String(description=&#39;测试文字&#39;)})@hello.route(&#39;/hello&#39;)class helloworld(Resource):    def get(self):        return &#39;hello world&#39;    @hello.expect(hello_model)    def post(self):        return api.payload.get(&#39;text&#39;, &#39;没有发送内容!&#39;)</code></pre><p>再对初始化服务代码进行一些修改</p><pre><code>#!/usr/bin/env python# -*- coding: utf-8 -*-from flask import Flaskdef start_aip():    &quot;&quot;&quot;    初始化API    :return:    &quot;&quot;&quot;    app = Flask(__name__)    from test.my_info import api    api.init_app(app, version=&#39;1.0&#39;, title=&#39;API&#39;, description=&#39;A test API&#39;)    return appif __name__ == &quot;__main__&quot;:    app = start_aip()    app.run(host=&#39;127.0.0.1&#39;, port=7777, debug=False, threaded=True)</code></pre><p>这样，我们就开启了一个简单的http服务，并且创建了一个 hello world 接口，以及一个在线api文档。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>flask</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用QtWebEngineWidgets开发Web浏览器</title>
    <link href="/2020/03/02/%E4%BD%BF%E7%94%A8QtWebEngineWidgets%E5%BC%80%E5%8F%91Web%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <url>/2020/03/02/%E4%BD%BF%E7%94%A8QtWebEngineWidgets%E5%BC%80%E5%8F%91Web%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>由于公司的项目常常使用混编模式开发，所以在客户端软件中嵌套web页面就成了必不可少的要求。<br>此次我使用到了PyQt5开发客户端界面，并尝试将web页面嵌套进客户端窗口内。<br>具体使用的Qt模块为QtWebEngineWidgets模块，该模块是在python里是需要单独安装和导入的。</p><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><pre><code>import sysfrom PyQt5.Qt import QApplicationfrom PyQt5.QtCore import QUrlfrom PyQt5.QtWidgets import QWidgetfrom PyQt5.QtWebEngineWidgets import QWebEngineViewclass my_Browser(QWidget):    def __init__(self):        super(my_Browser, self).__init__(None)        self.setFixedSize(1024, 768)        self.browser = QWebEngineView(self)  # web窗口        self.browserInit()  # 生成浏览器控件        self.openUrl(&#39;https://www.baidu.com/&#39;)        # self.openUrl(&#39;/百度一下，你就知道.mhtml&#39;)    def browserInit(self):        &quot;&quot;&quot;创建一个浏览器&quot;&quot;&quot;        self.browser.setFixedSize(1024, 768)    def openUrl(self, url):        &quot;&quot;&quot;打开网页&quot;&quot;&quot;        self.browser.load(QUrl(url))        # self.browser.load(QUrl.fromLocalFile(url))  # 打开本地路径的网页if __name__ == &quot;__main__&quot;:    win = QApplication(sys.argv)    myWin = my_Browser()    myWin.show()    sys.exit(win.exec_())</code></pre><blockquote><p>注意使用网页链接时需要完整的网页地址https和http是必须的；打开本地web文件只需要带人正确的路径即可，我这里直接放在了同一个目录下，百度的页面为.mhtml，当然.html肯定是可以的。</p></blockquote><p>上面为一个简单的案例，这里我在补充一个简单的知识的，开我们的开发中通常不会只是打开一个web页面这么简单，我们还会需要登录后台并实现web页面的自动登录，这里就需要用到cookie了。</p><h2 id="为url添加cookie信息"><a href="#为url添加cookie信息" class="headerlink" title="为url添加cookie信息"></a>为url添加cookie信息</h2><pre><code>from PyQt5.QtWebEngineWidgets import QWebEngineView, QWebEngineProfilefrom PyQt5.QtNetwork import QNetworkCookie    ...    def __init__(self):        super(my_Browser, self).__init__(None)        self.setFixedSize(1024, 768)        self.session = &#39;FSDF45643216546465DSD56464&#39;  # 这里随便瞎写一个，当然我们可以将其作为参数带入    ...    def openUrl(self, url):        &quot;&quot;&quot;打开网页&quot;&quot;&quot;        self.my_cookie = QNetworkCookie()        self.my_cookie.setName(&#39;JSESSIONID&#39;.encode())        self.my_cookie.setValue(self.session.encode())        self.my_cookie.setPath(&#39;/&#39;)        QWebEngineProfile.defaultProfile().cookieStore().deleteAllCookies()        QWebEngineProfile.defaultProfile().cookieStore().setCookie(self.my_cookie, QUrl(url))        self.browser.load(QUrl(url))        # self.browser.load(QUrl.fromLocalFile(url))  # 打开本地路径的网页    ...</code></pre><blockquote><p>QNetworkCookie.setPath(‘/‘)这里为cookie添加路径信息，应为web开发人员可能会将接口文件和页面文件分开放置。</p></blockquote><h2 id="关于页面跳转"><a href="#关于页面跳转" class="headerlink" title="关于页面跳转"></a>关于页面跳转</h2><p>在使用QWebEngineView的过程中我们会发现页面无法跳转的问题，这里我们需要重写一个方法：</p><pre><code>    def createWindow(self, QWebEnginePage_WebWindowType):        browser = My_Browser(self)        browser.urlChanged.connect(self.on_url_changed)        return browser</code></pre><p>关于使用QtWebEngineWidgets嵌套web页面还有很多知识，我会在之后的使用中在一一记录。</p>]]></content>
    
    
    
    <tags>
      
      <tag>PyQt5</tag>
      
      <tag>QtWebEngineWidgets</tag>
      
      <tag>Web浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyQt5自定义控件之环形进度条</title>
    <link href="/2020/02/28/PyQt5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E4%B9%8B%E7%8E%AF%E5%BD%A2%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    <url>/2020/02/28/PyQt5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E4%B9%8B%E7%8E%AF%E5%BD%A2%E8%BF%9B%E5%BA%A6%E6%9D%A1/</url>
    
    <content type="html"><![CDATA[<p>本文包含了QTimeLine、QPainter模块的运用<br>使用Qpainter绘制圆环图案，QTimeLine实现填充动画。<a href="https://blog.csdn.net/gongjianbo1992/article/details/103571569" target="_blank" rel="noopener">参考</a><br>追加了数字文字的变化动画。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>from PyQt5.Qt import QColor, QRectF, QConicalGradientfrom PyQt5.QtCore import Qt, QTimeLinefrom PyQt5.QtGui import QPainter, QPainterPath, QFontfrom PyQt5.QtWidgets import QLabelclass RingStatistics(QLabel):    def __init__(self, parent, width, color, ring_color=QColor(0, 0, 0, 0), gradient=None):        super(RingStatistics, self).__init__(parent)        # 记录角度        self.angle = 0        self.Ptext = &#39;0&#39;        self.precision = &#39;1&#39;        # 这个是用于绘制的，angle才是真实的角度        self.drawAngle = self.angle        self.drawText = self.Ptext        # 进度条宽度        self.lineWidth = width        # 环形时间轴        self.ringTime = QTimeLine(1000, self)        self.ringTime.frameChanged.connect(self.ringTimeline)        # 文字时间轴        self.textTime = QTimeLine(1000, self)        self.textTime.frameChanged.connect(self.TextTimeline)        # 填充色        self.color = color        self.ring_color = ring_color        # 渐变色        if gradient:            self.gradient = gradient        else:            self.gradient = self.color    def ringTimeline(self, frame):        &quot;&quot;&quot;环形时间轴&quot;&quot;&quot;        self.drawAngle = frame        self.update()    def TextTimeline(self, frame):        &quot;&quot;&quot;文字时间轴&quot;&quot;&quot;        self.drawText = format(float(frame) * float(self.precision), &#39;.&#39; + str(len(self.precision.split(&quot;.&quot;)[1])) + &#39;f&#39;)        self.update()    def setAngle(self, value, text):        &quot;&quot;&quot;设置值、播放动画&quot;&quot;&quot;        self.drawAngle = self.angle        self.angle = int(value * 360)        self.drawText = self.FloatToInt(self.Ptext)        self.Ptext = self.FloatToInt(float(text))        self.ringTime.stop()        self.ringTime.setFrameRange(self.drawAngle, self.angle)        self.ringTime.start()        self.textTime.stop()        self.textTime.setFrameRange(self.drawText, self.Ptext)        self.textTime.start()    def setPText(self, p_str=&#39;0&#39;, size=18, font=&#39;微软雅黑&#39;, color=QColor(0, 0, 0, 0), unit=&#39;&#39;):        &quot;&quot;&quot;初始化绘制的文字&quot;&quot;&quot;        self.Ptext = p_str        self.Psize = size        self.Pfont = font        self.Pcolor = color        self.unit = unit    def paintEvent(self, event):        the_rect = QRectF(0, 0, self.width(), self.height())        if the_rect.isNull():            return        # 画笔        painter = QPainter(self)        painter.fillRect(the_rect, QColor(0, 0, 0, 0))        painter.setRenderHints(QPainter.Antialiasing | QPainter.SmoothPixmapTransform, on=True)        # 镜像翻转，这样就是顺时针        painter.setViewport(self.width(), 0, -self.width(), self.height())        # 填充两个圆相交的部分        the_path = QPainterPath()        the_path.addEllipse(the_rect.adjusted(1, 1, -1, -1))        the_path.addEllipse(the_rect.adjusted(            1 + self.lineWidth, 1 + self.lineWidth, -1 - self.lineWidth, -1 - self.lineWidth))        painter.fillPath(the_path, self.ring_color)        # 径向渐变（参数为中心点和起始角度），默认时从右侧开始逆时针算的        the_gradient = QConicalGradient(the_rect.center(), 90)        the_angle = self.drawAngle / 360        the_gradient.setColorAt(0, self.color)        the_gradient.setColorAt(the_angle, self.gradient)        if the_angle + 0.001 &lt; 1:            the_gradient.setColorAt(the_angle + 0.001, QColor(0, 0, 0, 0))        painter.fillPath(the_path, the_gradient)        p = QPainter(self)        p.setRenderHint(QPainter.TextAntialiasing, True)        p.setPen(self.Pcolor)        p.setFont(QFont(self.Pfont, self.Psize))        if &#39;_&#39; in self.unit:            if self.unit[0] == &#39;_&#39;:                s = str(self.drawText) + self.unit[1:]            else:                s = self.unit[:-1] + str(self.drawText)        else:            s = str(self.drawText)        p.drawText(self.rect(), Qt.AlignCenter, s)    def FloatToInt(self, f):        &quot;&quot;&quot;处理浮点数数据&quot;&quot;&quot;        if &#39;.&#39; in str(f):            self.precision = &#39;0.&#39;            i = 0            while i &lt; len(str(f).split(&quot;.&quot;)[1]):                if i &lt; len(str(f).split(&quot;.&quot;)[1]) - 1:                    self.precision = self.precision + &#39;0&#39;                else:                    self.precision = self.precision + &#39;1&#39;                i += 1            return int(float(f) / float(self.precision))        else:            self.precision = &#39;1&#39;            return int(f)</code></pre><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><pre><code>    def ringTimeline(self, frame):        &quot;&quot;&quot;环形时间轴&quot;&quot;&quot;        self.drawAngle = frame        self.update()    def TextTimeline(self, frame):        &quot;&quot;&quot;文字时间轴&quot;&quot;&quot;        self.drawText = format(float(frame) * float(self.precision), &#39;.&#39; + str(len(self.precision.split(&quot;.&quot;)[1])) + &#39;f&#39;)        self.update()    def setAngle(self, value, text):        &quot;&quot;&quot;设置值、播放动画&quot;&quot;&quot;        self.drawAngle = self.angle        self.angle = int(value * 360)        self.drawText = self.FloatToInt(self.Ptext)        self.Ptext = self.FloatToInt(float(text))        self.ringTime.stop()        self.ringTime.setFrameRange(self.drawAngle, self.angle)        self.ringTime.start()        self.textTime.stop()        self.textTime.setFrameRange(self.drawText, self.Ptext)        self.textTime.start()</code></pre><blockquote><p>QTimeLine.setFrameRange() 设置动画起始值，和目标值。这里参数为 int 类型参数。</p></blockquote><pre><code>    def paintEvent(self, event):        the_rect = QRectF(0, 0, self.width(), self.height())        if the_rect.isNull():            return        # 画笔        painter = QPainter(self)        painter.fillRect(the_rect, QColor(0, 0, 0, 0))        painter.setRenderHints(QPainter.Antialiasing | QPainter.SmoothPixmapTransform, on=True)        # 镜像翻转，这样就是顺时针        painter.setViewport(self.width(), 0, -self.width(), self.height())        # 填充两个圆相交的部分        the_path = QPainterPath()        the_path.addEllipse(the_rect.adjusted(1, 1, -1, -1))        the_path.addEllipse(the_rect.adjusted(            1 + self.lineWidth, 1 + self.lineWidth, -1 - self.lineWidth, -1 - self.lineWidth))        painter.fillPath(the_path, self.ring_color)        # 径向渐变（参数为中心点和起始角度），默认时从右侧开始逆时针算的        the_gradient = QConicalGradient(the_rect.center(), 90)        the_angle = self.drawAngle / 360        the_gradient.setColorAt(0, self.color)        the_gradient.setColorAt(the_angle, self.gradient)        if the_angle + 0.001 &lt; 1:            the_gradient.setColorAt(the_angle + 0.001, QColor(0, 0, 0, 0))        painter.fillPath(the_path, the_gradient)        # 绘制文字        p = QPainter(self)        p.setRenderHint(QPainter.TextAntialiasing, True)        p.setPen(self.Pcolor)        p.setFont(QFont(self.Pfont, self.Psize))        if &#39;_&#39; in self.unit:            if self.unit[0] == &#39;_&#39;:                s = str(self.drawText) + self.unit[1:]            else:                s = self.unit[:-1] + str(self.drawText)        else:            s = str(self.drawText)        p.drawText(self.rect(), Qt.AlignCenter, s)</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="QPainterPath"><a href="#QPainterPath" class="headerlink" title="QPainterPath:"></a>QPainterPath:</h3><pre><code>QPainterPath.addEllipse  # 绘制椭圆形QPainterPath.addPolygon  # 多边形QPainterPath.addRect     # 矩形QPainterPath.addText     # 文字QPainterPath.arcTo       # 弧形QPainterPath.cubicTo     # 贝塞尔曲线</code></pre><h3 id="QRectF"><a href="#QRectF" class="headerlink" title="QRectF"></a>QRectF</h3><pre><code>QRectF.adjusted  # 四个端点的坐标偏移</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>PyQt5</tag>
      
      <tag>样式</tag>
      
      <tag>动画</tag>
      
      <tag>自定义控件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QtWebEngineWidgets在某些设备上崩溃的问题</title>
    <link href="/2020/02/24/QtWebEngineWidgets%E5%9C%A8%E6%9F%90%E4%BA%9B%E8%AE%BE%E5%A4%87%E4%B8%8A%E5%B4%A9%E6%BA%83%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/02/24/QtWebEngineWidgets%E5%9C%A8%E6%9F%90%E4%BA%9B%E8%AE%BE%E5%A4%87%E4%B8%8A%E5%B4%A9%E6%BA%83%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>今天遇到一个比较头疼的问题，使用了QtWebEngineWidgets模块开发的程序导出exe文件之后在某些设备上会崩溃的问题。<br>我碰到的设备具体都是win7的设备。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>这个问题不是很常见，网上答案也不多，大多说的是因为显卡驱动的原因，需要更新显卡驱动。不过我没有试过，具体有没有不知道。</p><p>而我使用的方法呢，是来自 <a href="https://blog.csdn.net/xujun1991/article/details/88122506?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">CSND</a> 上的文章他的第二点：</p><pre><code>2.必须把libEGL.dll、libGLESv2.dll、d3dcompiler_47.dll、opengl32sw.dll这些文件拷贝到对应的exe路径下。</code></pre><p>这里稍微有些不一样的地方，只需要将 程序的运行目录下\PyQt5\Qt\bin 里面的</p><pre><code>libEGL.dll；libGLESv2.dll；d3dcompiler_47.dll；opengl32sw.dll</code></pre><p>四个dll拷贝到exe运行路径下就可以正常运行了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>PyQt5</tag>
      
      <tag>QtWebEngineWidgets</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的PyQt5控件样式表</title>
    <link href="/2020/02/21/%E5%B8%B8%E7%94%A8%E7%9A%84PyQt5%E6%8E%A7%E4%BB%B6%E6%A0%B7%E5%BC%8F%E8%A1%A8/"/>
    <url>/2020/02/21/%E5%B8%B8%E7%94%A8%E7%9A%84PyQt5%E6%8E%A7%E4%BB%B6%E6%A0%B7%E5%BC%8F%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>在最近的工作中大量的使用了PyQt的.setStyleSheet方法来对控件的样式进行自定义，或者制作自己的控件</p><h2 id="常用样式"><a href="#常用样式" class="headerlink" title="常用样式"></a>常用样式</h2><pre><code>背景类：    background:rgb(245,254,254,1);    background-image:url(.../xxx.png);    border-image:url(.../xxx.png);    image:url();</code></pre><blockquote><p>注意：这里 background-image 和 border-image 都是设置背景图片，区别在于 border-image 图片可以自动适应控件的大小，而 background-image 不行。</p></blockquote><pre><code>文字类：    font-size:14px;  # 字号    font-family:Microsoft YaHei;  # 字体    font-weight:400;  # 笔重    color:rgba(30,159,255,1);  # 颜色    line-height:40px;  # 行距    文本对齐    text-align: left;    text-align: right;    text-align: top;    text-align: bottom;</code></pre><pre><code>边框类：    border:none;  # 无边框    border:1px solid rgb(255, 255, 255, 1);  # 全边框    border-top:1px solid rgb(255, 255, 255, 1);  # 上边框    border-right:1px solid rgb(255, 255, 255, 1);  # 右边框    border-left:1px solid rgb(255, 255, 255, 1);  # 左边框    border-bottom:1px solid rgb(255, 255, 255, 1);  # 下边框    border-radius:60%;  # 圆角，也可以使用像素做参数    padding-top:1px;  # 边距    padding-right:1px;    padding-left:1px;    padding-bottom:1px;    opacity:0.9;  # 透明度    outline: none;  # 虚线框</code></pre><h2 id="控件设置"><a href="#控件设置" class="headerlink" title="控件设置"></a>控件设置</h2><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><pre><code>QLabel{font-size:14px;       font-family:Microsoft YaHei;       font-weight:400;       color:rgba(51,51,51,1);       line-height:40px}</code></pre><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><pre><code>QPushButton{background:rgb(255,255,255,1);            border:none;            border-radius:25%}# 鼠标悬停样式            QPushButton:hover{background:rgb(30,159,255,1)}# 选中样式QPushButton:disabled{border-image: url(.../被选中.png)}</code></pre><h3 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h3><pre><code>QComboBox{background:rgba(245,245,245,1);          font-size:14px;          font-family:Microsoft YaHei;          font-weight:400;          color:rgba(51,51,51,1);          line-height:1px;          border:1px solid rgba(179,179,179,1);          border-radius:2px;          padding-left:18px}# 下拉按钮          QComboBox::drop-down{width: 52px;                     border: none}# 下拉按钮图标                     QComboBox::down-arrow {border-image: url(.../向下.png);                       height:16px;                       width:12px}# 下面三项需要先设置下面代码self.QComboBox.currentIndexChanged.connect(self.main_info.usernamechange)self.QComboBox.setView(QListView())# 下拉框样式QListView{outline:0px}# 下拉框选项QListView::item{border-bottom:1px solid rgb(230, 230, 230, 1);                padding-left:2px;                font-size:12px;                font-weight:400;                color:rgba(51,51,51,1);                line-height:1px;                height:18px}# 下拉框选项鼠标悬停QListView::item::hover{background:rgba(245, 245, 254, 0.9)})</code></pre><h3 id="输入框"><a href="#输入框" class="headerlink" title="输入框"></a>输入框</h3><pre><code>QLineEdit{background:rgba(245,245,245,1);          border:1px solid rgba(30,159,255,1);          opacity:0.9;             border-radius:2px;          font-size:14px;          font-family:Microsoft YaHei;          font-weight:400;          color:rgba(134,134,134,1);          line-height:72px;          padding-left:15px}</code></pre><h3 id="滑块"><a href="#滑块" class="headerlink" title="滑块"></a>滑块</h3><pre><code>horizontal换成vertical就是垂直的滑块# 滑块条QSlider::groove:horizontal{border:none;                           height:12px}# 以划过部分                           QSlider::sub-page:horizontal{background:rgba(0,191,255,0.5);                             border-radius:6px}# 未划过部分                             QSlider::add-page:horizontal{background:rgba(230,230,230,1);                             border-radius:6px}# 滑块                             QSlider::handle:horizontal{background:rgba(0,191,255,1);                           border:none;                           width:20px;                           height:20px;                           margin-top:-4px;                           margin-bottom:-4px;                           border-radius:10px}</code></pre><h3 id="勾选框"><a href="#勾选框" class="headerlink" title="勾选框"></a>勾选框</h3><pre><code># 勾选框主体QCheckBox{font-size:14px;          font-family:Microsoft YaHei;          font-weight:400;          color:rgba(51,51,51,1)}# 勾选框框体QCheckBox::indicator{width:18px;                     height:18px;                     border:1px solid rgba(179,179,179,1);                     border-radius:2px}# 勾选框勾选状态QCheckBox::indicator:checked{background:rgba(95,184,120,1);                             image:url()}</code></pre><h3 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h3><pre><code>vertical换成horizontal就是水平的滚动条预留上下按钮的位子：padding-top:18px;padding-bottom:18px# 滚动条主体QScrollBar:vertical{background:rgba(238,238,238,1);                    width:14px;                    padding-left:1px;                    padding-right:1px;                    padding-top:18px;                    padding-bottom:18px}# 滑块        QScrollBar::handle:vertical{background:rgba(204,204,204,1)}# 已经滑过的区域QScrollBar::sub-page:vertical{background:rgba(238,238,238,1);}# 还没滑过的区域QScrollBar::add-page:vertical{background:rgba(238,238,238,1);}# 向下按钮QScrollBar::add-line:vertical{height:18px;                              width:14px;                              image:url(image/setup_win/三角_u151.png)}# 向上按钮                              QScrollBar::sub-line:vertical{height:18px;                              width:14px;                              image:url(image/setup_win/三角_u151 - 副本.png)}</code></pre><h3 id="QListWidget列表"><a href="#QListWidget列表" class="headerlink" title="QListWidget列表"></a>QListWidget列表</h3><pre><code>QListWidget{border:none;            outline: none}# 项            QListWidget::item{outline: none}# 鼠标悬停在项上QListWidget::item:hover{background:rgba(0,0,0,0)}# 项被选择状态QListWidget::item:selected{background:rgba(0,0,0,0)</code></pre><blockquote><p>本文用于记录我在工作中常用的控件样式表，后续还会继续更新。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>PyQt5</tag>
      
      <tag>样式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyQt5 自定义窗口标题栏, 实现窗口拖拽</title>
    <link href="/2020/02/13/PyQt5%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AA%97%E5%8F%A3%E6%A0%87%E9%A2%98%E6%A0%8F,%E5%AE%9E%E7%8E%B0%E7%AA%97%E5%8F%A3%E6%8B%96%E6%8B%BD/"/>
    <url>/2020/02/13/PyQt5%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AA%97%E5%8F%A3%E6%A0%87%E9%A2%98%E6%A0%8F,%E5%AE%9E%E7%8E%B0%E7%AA%97%E5%8F%A3%E6%8B%96%E6%8B%BD/</url>
    
    <content type="html"><![CDATA[<p>最近在使用pyqt5做窗口应用程序，因为原始的标题栏不能满足需求我们常常会使用到自定义的标题栏。<br>本篇放上一个最简单的例子提供参考</p><h2 id="隐藏原始标题栏"><a href="#隐藏原始标题栏" class="headerlink" title="隐藏原始标题栏"></a>隐藏原始标题栏</h2><pre><code>class test(QMainWindow):    def __init__(self):        super(test, self).__init__(None, Qt.FramelessWindowHint)  # 无边框设置        self.setFixedSize(880, 640)        self.setStyleSheet(&quot;QMainWindow{background:rgba(255,255,255,255)}&quot;)        self.init()</code></pre><blockquote><p>使用 Qt.FramelessWindowHint将我们的窗口设置为无边框窗口</p></blockquote><h2 id="创建一个标题栏"><a href="#创建一个标题栏" class="headerlink" title="创建一个标题栏"></a>创建一个标题栏</h2><pre><code>    def init(self):        # 创建一个标题栏        self.titlebar = QLabel(self)        self.titlebar.setFixedSize(880, 40)        self.titlebar.move(0, 0)        self.titlebar.setStyleSheet(&quot;QLabel{background:rgba(245,245,245,255)}&quot;)        # 图标        self.icon = QLabel(self)        self.icon.setFixedSize(20, 20)        self.icon.move(10, 10)        self.icon.setStyleSheet(&quot;QLabel{background-image: url(image/main_win/icon.png)}&quot;)        # 标题        self.title = QLabel(self)        self.title.setText(&#39;我的自定义标题栏&#39;)        self.title.move(37, 6)        self.title.setStyleSheet(&quot;QLabel{font-size:14px;&quot;                                 &quot;font-family:Microsoft YaHei;&quot;                                 &quot;font-weight:400;&quot;                                 &quot;color:rgba(51,51,51,1);&quot;                                 &quot;line-height:1px;&quot;)        # 关闭按钮        self.close_btn = QPushButton(self)        self.close_btn.setFixedSize(16, 16)        self.close_btn.move(842, 18)        self.close_btn.setStyleSheet(&quot;QPushButton{background-image: url(image/main_win/close.png);&quot;                                     &quot;border:none}&quot;)        self.close_btn.pressed.connect(self.close)        # # 最大化按钮        # self.max_btn = QPushButton(self)        # self.max_btn.setFixedSize(16, 16)        # self.max_btn.move(792, 18)        # self.max_btn.setStyleSheet(&quot;QPushButton{background-image: url(image/main_win/min.png);&quot;        #                            &quot;border:none}&quot;)        # self.max_btn.pressed.connect(self.ShowRestoreWindow)        # 最小化按钮        self.min_btn = QPushButton(self)        self.min_btn.setFixedSize(16, 16)        self.min_btn.move(742, 18)        self.min_btn.setStyleSheet(&quot;QPushButton{background-image: url(image/main_win/min.png);&quot;                                   &quot;border:none}&quot;)        self.min_btn.pressed.connect(self.showMinimized)    # def ShowRestoreWindow(self):    #     &quot;&quot;&quot;窗口最大化以及恢复&quot;&quot;&quot;    #     if self.isMaximized():    #         self.showNormal()    #     else:    #         self.showMaximized()    #     self.titleSize()    def mousePressEvent(self, QMouseEvent):        &quot;&quot;&quot;鼠标点击事件&quot;&quot;&quot;        if QMouseEvent.y() &lt; self.titlebar.height():  # 限制在标题栏区域内            self.startMovePos = QMouseEvent.globalPos()    def mouseMoveEvent(self, QMouseEvent):        &quot;&quot;&quot;鼠标拖拽事件&quot;&quot;&quot;        if QMouseEvent.y() &lt; self.titlebar.height():  # 限制在标题栏区域内            movePoint = QMouseEvent.globalPos() - self.startMovePos            widgetPos = self.pos()            self.startMovePos = QMouseEvent.globalPos()            self.move(widgetPos.x() + movePoint.x(), widgetPos.y() + movePoint.y())</code></pre><blockquote><p>这里我注释掉了最大化窗口事件，因为没有做好控件的自适应方案。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>PyQt5 应用</tag>
      
      <tag>自定义标题栏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客搭建及git部署</title>
    <link href="/2020/02/10/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8F%8Agit%E9%83%A8%E7%BD%B2/"/>
    <url>/2020/02/10/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8F%8Agit%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>本文用于记录我在创建hexo博客时的方法和步骤。<br>这是我第一次创建自己的博客，使用hexo主要是因为他的创建方法很简单，还可以通过git部署到公网。<br>这篇文章大部分参考了hexo的 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a> 所有内容在官方文档中都有更加详细的说明。</p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>Hexo 是一个快速、简洁且高效的博客框架。hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">官网</a></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>在你要存放博客的文件夹下使用命令窗口输入:</p><pre><code>$ npm install -g hexo-cli</code></pre><p>hexo是机遇 <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js</a> 的，所以在安装hexo之前我们需要先安装好Node.js<br>因为我们后面要使用git将我们的博客部署到公网所以也需要先把 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a> 安装好</p><blockquote><p>使用Node.js官方安装程序时，请确保勾选 Add to PATH 选项（默认已勾选）</p></blockquote><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><pre><code>$ hexo init$ npm install</code></pre><p>这个过程需要一些时间<br>创建好后会得到这样的文件结构</p><pre><code>.|——_config.yml  # 网站的配置信息|——package.json  # 应用程序信息|——scaffolds  # 模板文件夹|——source  # 资源文件夹|  |__ _posts  # 文章文件夹|__themes  # 主题文件夹</code></pre><p>我们可以在 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">_config.yml</a> 中修改大部分的配置<br>到这里我们的hexo博客就建好了，接下来就是将我们的博客部署到公网上了。</p><h2 id="博客部署到公网"><a href="#博客部署到公网" class="headerlink" title="博客部署到公网"></a>博客部署到公网</h2><p>关于如何将博客部署到公网，这里就要用到我们强大的git了。</p><p>首先我们需要在git上创建一个新仓库。</p><blockquote><p>注意: 仓库名必须是 [你的github用户名.github.io]</p></blockquote><p>然后我们需要生成ssh秘钥文件，因为Hexo部署在github上是通过密钥配对上传的。<br>Windows搜索打开Git Bash 输入</p><pre><code>git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot;ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;cd ~/.ssh</code></pre><p>Windows密钥文件在C:/Users/你的用户名/.ssh目录下。<br>打开git个人设置-SSH and GPG keys 页面- New SSH key 将刚刚复制的id_rsa.pub内容粘贴到key，最后点击Add SSH key。</p><h3 id="网站部署"><a href="#网站部署" class="headerlink" title="网站部署"></a>网站部署</h3><p>设置好git仓库后还需要修改hexo的配置文件，修改_config.yml</p><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: https://github.com/你的github用户名/你的github用户名.github.io.git  branch: master</code></pre><p>修改好后使用</p><pre><code>hexo d</code></pre><p>既可以在公网上通过 [你的github用户名.github.io] 看到你的个人博客啦。</p><h2 id="git同步管理"><a href="#git同步管理" class="headerlink" title="git同步管理"></a>git同步管理</h2><p>既然我们使用了git部署个人博客，那么能不能使用git来做博客的同步管理呢？<br>当然是可以的。<br>在博客根目录下打开Git Bassh</p><pre><code>git init #git初始化git remote add origin https://github.com/你的GitHub用户名/你的GitHub用户名.github.io.git #添加仓库地址git checkout -b 分支名 #新建分支并切换到新建的分支git add . #添加所有本地文件到gitgit commit -m &quot;这里填写你本次提交的备注&quot; #git提交git push origin 分支名 #文件推送到hexo分支</code></pre><p>比如这样：</p><pre><code>git init #git初始化git remote add origin https://github.com/xxx/xxx.github.io.git #添加仓库地址git checkout -b hexo #新建分支并切换到新建的分支git add . #添加所有本地文件到gitgit commit -m &quot;我的hexo同步文件&quot; #git提交git push origin hexo #文件推送到hexo分支</code></pre><p>这样就把博客项目上传到了git仓库的hexo分支下</p><h3 id="在另一台电脑下载博客工程"><a href="#在另一台电脑下载博客工程" class="headerlink" title="在另一台电脑下载博客工程"></a>在另一台电脑下载博客工程</h3><pre><code>git clone -b 分支名 https://github.com/你的GitHub用户/你的GitHub用户.github.io.git</code></pre><p>克隆下载完成后，进入到你项目的文件夹，配置你的hexo环境</p><pre><code>npm install -g hexo-cli #安装hexo,注意这里不需要hexo初始化,否则之前的hexo配置参数会重置npm install #安装依赖库npm install hexo-deployer-git #安装git部署相关配置</code></pre><blockquote><p>这里同样是要使用到ssh秘钥的，生成方式同上</p></blockquote><h3 id="文件的上传和更新"><a href="#文件的上传和更新" class="headerlink" title="文件的上传和更新"></a>文件的上传和更新</h3><pre><code>git add .git commit -m &quot;这里填写你本次提交的备注&quot;git push origin 分支名</code></pre><p>需要更新git上的项目文件时只需要执行上面的代码即可</p><p>同步只需要执行</p><pre><code>git pull</code></pre><p>到这我们不仅将博客部署到了公网上，还能够通过git进行同步管理啦。</p>]]></content>
    
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
      <tag>git同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/01/22/hello-world/"/>
    <url>/2020/01/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
